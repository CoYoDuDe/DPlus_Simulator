#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="${SCRIPT_DIR}"
INSTALL_ROOT="${INSTALL_ROOT:-/opt/dplus_sim}"
SERVICE_NAME="com.coyodude.dplussim"
SERVICE_INSTALL_DIR="${INSTALL_ROOT}/services/${SERVICE_NAME}"
HELPER_RESOURCE="/data/SetupHelper/HelperResources/IncludeHelpers"
SETTINGS_BASE_PATH="/Settings/Devices/DPlusSim"
PACKAGE_DEPENDENCIES_FILE="${PROJECT_ROOT}/packageDependencies"

filesUpdated=false
servicesUpdated=false
dbusSettingsUpdated=false
declare -a _dbus_settings_entries=()

log() {
  local level="${1^^}"
  shift
  if declare -F logMessage >/dev/null; then
    logMessage "${level}" "$*"
    return
  fi
  printf '[%s] %s\n' "${level}" "$*"
}

die() {
  log ERROR "$*"
  exit 1
}

copy_tree() {
  local src="$1"
  local dest="$2"
  mkdir -p "${dest}"
  if command -v rsync >/dev/null 2>&1; then
    rsync -a --delete "${src}/" "${dest}/"
  else
    tar -C "${src}" -cf - . | tar -C "${dest}" -xf -
  fi
}
call_helper_function_if_available() {
  local fn="$1"
  shift || true
  if ! declare -F "${fn}" >/dev/null; then
    return 127
  fi

  # Temporär striktes Fehler-Handling deaktivieren, um alternative Aufrufe
  # ausprobieren zu können, ohne das Skript sofort abzubrechen.
  set +e
  "${fn}" "$@"
  local status=$?
  set -e
  return ${status}
}

source_helper_resources() {
  local helper_path="${HELPER_RESOURCE}"

  if [[ -f "${helper_path}" ]]; then
    if [[ ! -r "${helper_path}" ]]; then
      die "SetupHelper-Ressource ${helper_path} nicht lesbar"
    fi
    # shellcheck disable=SC1090
    source "${helper_path}"
    return
  fi

  local -a helper_files=(
    "${helper_path}/CommonResources"
    "${helper_path}/ServiceResources"
    "${helper_path}/DbusSettingsResources"
  )

  local missing=0
  for file in "${helper_files[@]}"; do
    if [[ ! -r "${file}" ]]; then
      log WARN "SetupHelper-Ressource ${file} nicht gefunden"
      missing=1
      continue
    fi
    # shellcheck disable=SC1090
    source "${file}"
  done

  if (( missing )); then
    die "Erforderliche SetupHelper-Ressourcen konnten nicht geladen werden"
  fi
}

begin_helper_session() {
  if declare -F beginScript >/dev/null; then
    beginScript
    return
  fi
  if declare -F helper_begin >/dev/null; then
    helper_begin
  fi
}

end_helper_session() {
  if declare -F endScript >/dev/null; then
    endScript
    return
  fi
  if declare -F helper_end >/dev/null; then
    helper_end
  fi
}

install_service() {
  if call_helper_function_if_available installService "${SERVICE_NAME}" "${SERVICE_INSTALL_DIR}"; then
    return
  fi
  if call_helper_function_if_available helper_install_service "${SERVICE_NAME}" "${SERVICE_INSTALL_DIR}"; then
    return
  fi
  die "SetupHelper stellt keine Funktion zum Installieren des Dienstes bereit"
}

remove_service() {
  if call_helper_function_if_available removeService "${SERVICE_NAME}"; then
    return
  fi
  if call_helper_function_if_available helper_uninstall_service "${SERVICE_NAME}"; then
    return
  fi
  die "SetupHelper stellt keine Funktion zum Entfernen des Dienstes bereit"
}

build_dbus_settings_entries() {
  local list_path="$1"
  if [[ ! -f "${list_path}" ]]; then
    die "settingsList ${list_path} nicht gefunden"
  fi
  mapfile -t _dbus_settings_entries < "${list_path}"
}

register_dbus_settings() {
  local list_path="${PROJECT_ROOT}/settingsList"
  build_dbus_settings_entries "${list_path}"

  if call_helper_function_if_available addAllDbusSettingsFromFile "${list_path}"; then
    dbusSettingsUpdated=true
    return
  fi

  if declare -F addAllDbusSettings >/dev/null; then
    local settings_list_output=""
    if declare -F DbusSettingsList >/dev/null; then
      set +e
      settings_list_output="$(DbusSettingsList "${_dbus_settings_entries[@]}")"
      local list_status=$?
      set -e
      if [[ ${list_status} -eq 0 && -n "${settings_list_output}" ]]; then
        call_helper_function_if_available addAllDbusSettings "${settings_list_output}" && {
          dbusSettingsUpdated=true
          return
        }
      fi
    fi

    if call_helper_function_if_available addAllDbusSettings "${list_path}"; then
      dbusSettingsUpdated=true
      return
    fi

    if call_helper_function_if_available addAllDbusSettings "${_dbus_settings_entries[@]}"; then
      dbusSettingsUpdated=true
      return
    fi
  fi

  if declare -F helper_register_settings_with_metadata >/dev/null || declare -F helper_register_settings >/dev/null; then
    if register_settings_definitions; then
      dbusSettingsUpdated=true
      return
    fi
  fi

  die "SetupHelper stellt keine geeignete Funktion zum Registrieren der Einstellungen bereit"
}

unregister_dbus_settings() {
  local list_path="${PROJECT_ROOT}/settingsList"
  build_dbus_settings_entries "${list_path}"

  if call_helper_function_if_available removeDbusSettingsFromFile "${list_path}"; then
    dbusSettingsUpdated=true
    return
  fi

  if declare -F removeDbusSettings >/dev/null; then
    local settings_list_output=""
    if declare -F DbusSettingsList >/dev/null; then
      set +e
      settings_list_output="$(DbusSettingsList "${_dbus_settings_entries[@]}")"
      local list_status=$?
      set -e
      if [[ ${list_status} -eq 0 && -n "${settings_list_output}" ]]; then
        call_helper_function_if_available removeDbusSettings "${settings_list_output}" && {
          dbusSettingsUpdated=true
          return
        }
      fi
    fi

    if call_helper_function_if_available removeDbusSettings "${list_path}"; then
      dbusSettingsUpdated=true
      return
    fi

    if call_helper_function_if_available removeDbusSettings "${_dbus_settings_entries[@]}"; then
      dbusSettingsUpdated=true
      return
    fi
  fi

  if declare -F helper_unregister_settings >/dev/null; then
    if helper_unregister_settings "${SETTINGS_BASE_PATH}"; then
      dbusSettingsUpdated=true
      return
    fi
  fi

  log WARN "Einstellungsderegistrierung konnte nicht über SetupHelper durchgeführt werden"
}

service_is_up() {
  if declare -F serviceIsUp >/dev/null; then
    set +e
    serviceIsUp "${SERVICE_NAME}"
    local status=$?
    set -e
    return ${status}
  fi

  if declare -F helper_print_service_status >/dev/null; then
    helper_print_service_status "${SERVICE_NAME}"
    return 0
  fi

  log INFO "Statusabfrage für Dienst ${SERVICE_NAME} nicht verfügbar"
  return 1
}

register_package_dependencies() {
  if [[ ! -f "${PACKAGE_DEPENDENCIES_FILE}" ]]; then
    log WARN "packageDependencies-Datei fehlt, überspringe Registrierung"
    return
  fi

  if declare -F helper_enable_dependency_conflict_checks >/dev/null; then
    helper_enable_dependency_conflict_checks
  elif declare -F helper_enable_package_conflict_checks >/dev/null; then
    helper_enable_package_conflict_checks
  else
    log WARN "SetupHelper bietet keine Konfliktprüfung, Registrierung läuft ohne zusätzliche Prüfung"
  fi

  if declare -F helper_register_package_dependencies >/dev/null; then
    helper_register_package_dependencies "${PACKAGE_DEPENDENCIES_FILE}"
  elif declare -F helper_use_package_dependencies >/dev/null; then
    helper_use_package_dependencies "${PACKAGE_DEPENDENCIES_FILE}"
  else
    die "SetupHelper unterstützt das Registrieren von packageDependencies nicht"
  fi
}

register_settings_definitions() {
  local -a settings_definitions=(
    "/Settings/Devices/DPlusSim/GpioPin|i|17|GPIO-Pin, der die simulierte D+-Leitung schaltet."
    "/Settings/Devices/DPlusSim/TargetVoltage|f|3.3|Zielspannung in Volt, die durch die Simulation angestrebt wird."
    "/Settings/Devices/DPlusSim/Hysteresis|f|0.1|Hystereseband in Volt, bevor der GPIO neu geschaltet wird."
    "/Settings/Devices/DPlusSim/ActivationDelaySeconds|f|2.0|Verzögerung in Sekunden, bevor der GPIO bei steigender Spannung eingeschaltet wird."
    "/Settings/Devices/DPlusSim/DeactivationDelaySeconds|f|5.0|Verzögerung in Sekunden, bevor der GPIO bei fallender Spannung ausgeschaltet wird."
    "/Settings/Devices/DPlusSim/OnVoltage|f|3.35|Spannung, ab der die D+-Simulation aktiviert werden soll."
    "/Settings/Devices/DPlusSim/OffVoltage|f|3.25|Spannung, unter der die D+-Simulation deaktiviert wird."
    "/Settings/Devices/DPlusSim/OnDelaySec|f|2.0|Verzögerung in Sekunden bis zum Einschalten, sobald alle Bedingungen erfüllt sind."
    "/Settings/Devices/DPlusSim/OffDelaySec|f|5.0|Verzögerung in Sekunden bis zum Ausschalten, wenn die Bedingungen entfallen."
    "/Settings/Devices/DPlusSim/UseIgnition|b|0|Aktiviert die Abhängigkeit vom Zündplus-Eingang."
    "/Settings/Devices/DPlusSim/IgnitionGpio|i|4|GPIO-Pin, an dem das Zündplus-Signal eingelesen wird."
    "/Settings/Devices/DPlusSim/IgnitionPull|s|down|Pull-Up/-Down-Konfiguration für den Zündplus-Eingang (up/down/none)."
    "/Settings/Devices/DPlusSim/ForceOn|b|0|Erzwingt dauerhaft ein aktives D+-Signal."
    "/Settings/Devices/DPlusSim/ForceOff|b|0|Erzwingt dauerhaft ein deaktiviertes D+-Signal."
    "/Settings/Devices/DPlusSim/StatusPublishInterval|f|2.0|Intervall in Sekunden zur Veröffentlichung des Status über D-Bus-Signale."
    "/Settings/Devices/DPlusSim/DbusBus|s|system|Zu verwendender D-Bus (system oder session)."
    "/Settings/Devices/DPlusSim/ServicePath|s|com.victronenergy.battery|D-Bus-Service, aus dem die Spannung gelesen wird."
    "/Settings/Devices/DPlusSim/VoltagePath|s|/Dc/0/Voltage|Objektpfad des Spannungswertes."
  )

  local metadata_payload=""
  local fallback_payload=""

  while IFS='|' read -r path type default desc; do
    local fallback_default="${default}"
    local metadata_default="${default}"

    if [[ "${type}" == "b" ]]; then
      case "${default}" in
        1|true|TRUE)
          fallback_default="1"
          metadata_default="true"
          ;;
        0|false|FALSE|'')
          fallback_default="0"
          metadata_default="false"
          ;;
        *)
          die "Ungültiger Standardwert ${default} für boolesche Einstellung ${path}"
          ;;
      esac
    fi

    metadata_payload+="${path}|${type}|${metadata_default}|${desc}"$'\n'
    fallback_payload+="${path} ${type} ${fallback_default}"$'\n'
  done < <(printf '%s\n' "${settings_definitions[@]}")

  if declare -F helper_register_settings_with_metadata >/dev/null; then
    helper_register_settings_with_metadata <<EOF
${metadata_payload%$'\n'}
EOF
    return
  fi

  helper_register_settings <<EOF
${fallback_payload%$'\n'}
EOF
}


install_payload() {
  log INFO "Installationsdateien nach ${INSTALL_ROOT} kopieren"
  mkdir -p "${INSTALL_ROOT}"

  copy_tree "${PROJECT_ROOT}/src" "${INSTALL_ROOT}/src"
  copy_tree "${PROJECT_ROOT}/services" "${INSTALL_ROOT}/services"

  install -m 644 "${PROJECT_ROOT}/src/settings_schema.json" "${INSTALL_ROOT}/settings_schema.json"
  install -m 644 "${PROJECT_ROOT}/version" "${INSTALL_ROOT}/version"
  install -m 644 "${PROJECT_ROOT}/packageDependencies" "${INSTALL_ROOT}/packageDependencies"
  install -m 644 "${PROJECT_ROOT}/gitHubInfo" "${INSTALL_ROOT}/gitHubInfo"
  install -m 644 "${PROJECT_ROOT}/settingsList" "${INSTALL_ROOT}/settingsList"

  if [[ -d "${PROJECT_ROOT}/FileSets" ]]; then
    copy_tree "${PROJECT_ROOT}/FileSets" "${INSTALL_ROOT}/FileSets"
  fi
}

perform_install() {
  filesUpdated=false
  servicesUpdated=false
  dbusSettingsUpdated=false

  begin_helper_session
  register_package_dependencies

  install_payload
  filesUpdated=true

  install_service
  servicesUpdated=true

  register_dbus_settings

  end_helper_session
  log INFO "Installation abgeschlossen"
}

perform_uninstall() {
  filesUpdated=false
  servicesUpdated=false
  dbusSettingsUpdated=false

  begin_helper_session
  register_package_dependencies

  unregister_dbus_settings

  remove_service
  servicesUpdated=true

  if [[ -d "${INSTALL_ROOT}" ]]; then
    log INFO "Entferne Installationsverzeichnis ${INSTALL_ROOT}"
    rm -rf "${INSTALL_ROOT}"
    filesUpdated=true
  fi

  end_helper_session
  log INFO "Deinstallation abgeschlossen"
}

perform_status() {
  filesUpdated=false
  servicesUpdated=false
  dbusSettingsUpdated=false

  begin_helper_session
  register_package_dependencies

  local status_reported=false
  if declare -F serviceIsUp >/dev/null; then
    if service_is_up; then
      log INFO "Dienst ${SERVICE_NAME} ist aktiv"
    else
      log WARN "Dienst ${SERVICE_NAME} ist nicht aktiv"
    fi
    status_reported=true
  fi

  if [[ "${status_reported}" == false ]] && declare -F helper_print_service_status >/dev/null; then
    helper_print_service_status "${SERVICE_NAME}"
    status_reported=true
  fi

  if [[ "${status_reported}" == false ]]; then
    log WARN "Keine Statusfunktion für Dienst ${SERVICE_NAME} verfügbar"
  fi

  end_helper_session
}

usage() {
  cat <<USAGE
Verwendung: ${0##*/} <install|uninstall|status>
USAGE
}

main() {
  local cli_action="${1:-}"
  local normalized_cli=""

  if [[ -n "${cli_action}" ]]; then
    case "${cli_action}" in
      install|uninstall|status)
        normalized_cli="${cli_action}"
        ;;
      -h|--help)
        usage
        return 0
        ;;
      *)
        usage
        return 1
        ;;
    esac
  fi

  local helper_action="${scriptAction:-}"
  if [[ -z "${helper_action}" ]]; then
    case "${normalized_cli:-install}" in
      install)
        helper_action="INSTALL"
        normalized_cli="install"
        ;;
      uninstall)
        helper_action="UNINSTALL"
        ;;
      status)
        helper_action="CHECK"
        ;;
    esac
  else
    local expected_from_cli=""
    case "${normalized_cli}" in
      install) expected_from_cli="INSTALL" ;;
      uninstall) expected_from_cli="UNINSTALL" ;;
      status) expected_from_cli="CHECK" ;;
    esac

    if [[ -n "${expected_from_cli}" && "${helper_action}" != "${expected_from_cli}" ]]; then
      log WARN "scriptAction ${helper_action} stimmt nicht mit der CLI-Aktion ${normalized_cli} überein; verwende CLI-Aktion"
      helper_action="${expected_from_cli}"
    fi

    if [[ -z "${normalized_cli}" ]]; then
      case "${helper_action}" in
        INSTALL) normalized_cli="install" ;;
        UNINSTALL) normalized_cli="uninstall" ;;
        CHECK) normalized_cli="status" ;;
        *)
          log WARN "Unbekannte scriptAction ${helper_action}, verwende INSTALL"
          helper_action="INSTALL"
          normalized_cli="install"
          ;;
      esac
    fi
  fi

  scriptAction="${helper_action}"

  source_helper_resources

  case "${scriptAction}" in
    INSTALL)
      perform_install
      ;;
    UNINSTALL)
      perform_uninstall
      ;;
    CHECK)
      perform_status
      ;;
    *)
      log ERROR "Unbekannte scriptAction ${scriptAction}"
      usage
      return 1
      ;;
  esac
}

main "$@"
