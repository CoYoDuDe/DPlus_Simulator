#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="${SCRIPT_DIR}"
INSTALL_ROOT="${INSTALL_ROOT:-/opt/dplus_sim}"
SERVICE_NAME="com.coyodude.dplussim"
SERVICE_INSTALL_DIR="${INSTALL_ROOT}/services/${SERVICE_NAME}"
HELPER_RESOURCE="/data/SetupHelper/HelperResources/forSetupScript"
SETTINGS_BASE_PATH="/Settings/Devices/DPlusSim"
readarray -t SETTINGS_DEFINITIONS <<'SETTINGS'
/Settings/Devices/DPlusSim/GpioPin|i|17|GPIO-Pin, der die simulierte D+-Leitung schaltet.
/Settings/Devices/DPlusSim/TargetVoltage|d|3.3|Zielspannung in Volt, die durch die Simulation angestrebt wird.
/Settings/Devices/DPlusSim/Hysteresis|d|0.1|Hystereseband in Volt, bevor der GPIO neu geschaltet wird.
/Settings/Devices/DPlusSim/ActivationDelaySeconds|d|2.0|Verzögerung in Sekunden, bevor der GPIO bei steigender Spannung eingeschaltet wird.
/Settings/Devices/DPlusSim/DeactivationDelaySeconds|d|5.0|Verzögerung in Sekunden, bevor der GPIO bei fallender Spannung ausgeschaltet wird.
/Settings/Devices/DPlusSim/OnVoltage|d|3.35|Spannung, ab der die D+-Simulation aktiviert werden soll.
/Settings/Devices/DPlusSim/OffVoltage|d|3.25|Spannung, unter der die D+-Simulation deaktiviert wird.
/Settings/Devices/DPlusSim/OnDelaySec|d|2.0|Verzögerung in Sekunden bis zum Einschalten, sobald alle Bedingungen erfüllt sind.
/Settings/Devices/DPlusSim/OffDelaySec|d|5.0|Verzögerung in Sekunden bis zum Ausschalten, wenn die Bedingungen entfallen.
/Settings/Devices/DPlusSim/UseIgnition|b|false|Aktiviert die Abhängigkeit vom Zündplus-Eingang.
/Settings/Devices/DPlusSim/IgnitionGpio|i|4|GPIO-Pin, an dem das Zündplus-Signal eingelesen wird.
/Settings/Devices/DPlusSim/IgnitionPull|s|down|Pull-Up/-Down-Konfiguration für den Zündplus-Eingang (up/down/none).
/Settings/Devices/DPlusSim/ForceOn|b|false|Erzwingt dauerhaft ein aktives D+-Signal.
/Settings/Devices/DPlusSim/ForceOff|b|false|Erzwingt dauerhaft ein deaktiviertes D+-Signal.
/Settings/Devices/DPlusSim/StatusPublishInterval|d|2.0|Intervall in Sekunden zur Veröffentlichung des Status über D-Bus-Signale.
/Settings/Devices/DPlusSim/DbusBus|s|system|Zu verwendender D-Bus (system oder session).
/Settings/Devices/DPlusSim/ServicePath|s|com.victronenergy.battery|D-Bus-Service, aus dem die Spannung gelesen wird.
/Settings/Devices/DPlusSim/VoltagePath|s|/Dc/0/Voltage|Objektpfad des Spannungswertes.
SETTINGS
PACKAGE_DEPENDENCIES_FILE="${PROJECT_ROOT}/packageDependencies"

log() {
  local level="$1"
  shift
  printf '[%s] %s\n' "${level}" "$*"
}

die() {
  log ERROR "$*"
  exit 1
}

copy_tree() {
  local src="$1"
  local dest="$2"
  mkdir -p "${dest}"
  if command -v rsync >/dev/null 2>&1; then
    rsync -a --delete "${src}/" "${dest}/"
  else
    tar -C "${src}" -cf - . | tar -C "${dest}" -xf -
  fi
}

require_helper_function() {
  local fn="$1"
  if ! declare -F "${fn}" >/dev/null; then
    die "SetupHelper stellt die benötigte Funktion ${fn} nicht bereit"
  fi
}

source_setup_helper() {
  if [[ ! -r "${HELPER_RESOURCE}" ]]; then
    die "SetupHelper-Ressource ${HELPER_RESOURCE} nicht gefunden"
  fi
  # shellcheck disable=SC1090
  source "${HELPER_RESOURCE}"

  local required_functions=(
    helper_begin
    helper_end
    helper_install_service
    helper_uninstall_service
    helper_print_service_status
    helper_register_settings
    helper_unregister_settings
  )
  for fn in "${required_functions[@]}"; do
    require_helper_function "${fn}"
  done
}

register_package_dependencies() {
  if [[ ! -f "${PACKAGE_DEPENDENCIES_FILE}" ]]; then
    log WARN "packageDependencies-Datei fehlt, überspringe Registrierung"
    return
  fi

  if declare -F helper_enable_dependency_conflict_checks >/dev/null; then
    helper_enable_dependency_conflict_checks
  elif declare -F helper_enable_package_conflict_checks >/dev/null; then
    helper_enable_package_conflict_checks
  else
    log WARN "SetupHelper bietet keine Konfliktprüfung, Registrierung läuft ohne zusätzliche Prüfung"
  fi

  if declare -F helper_register_package_dependencies >/dev/null; then
    helper_register_package_dependencies "${PACKAGE_DEPENDENCIES_FILE}"
  elif declare -F helper_use_package_dependencies >/dev/null; then
    helper_use_package_dependencies "${PACKAGE_DEPENDENCIES_FILE}"
  else
    die "SetupHelper unterstützt das Registrieren von packageDependencies nicht"
  fi
}

install_payload() {
  log INFO "Installationsdateien nach ${INSTALL_ROOT} kopieren"
  mkdir -p "${INSTALL_ROOT}"

  copy_tree "${PROJECT_ROOT}/src" "${INSTALL_ROOT}/src"
  copy_tree "${PROJECT_ROOT}/services" "${INSTALL_ROOT}/services"

  install -m 644 "${PROJECT_ROOT}/src/settings_schema.json" "${INSTALL_ROOT}/settings_schema.json"
  install -m 644 "${PROJECT_ROOT}/version" "${INSTALL_ROOT}/version"
  install -m 644 "${PROJECT_ROOT}/packageDependencies" "${INSTALL_ROOT}/packageDependencies"
  install -m 644 "${PROJECT_ROOT}/gitHubInfo" "${INSTALL_ROOT}/gitHubInfo"
  install -m 644 "${PROJECT_ROOT}/settingsList" "${INSTALL_ROOT}/settingsList"

  if [[ -d "${PROJECT_ROOT}/FileSets" ]]; then
    copy_tree "${PROJECT_ROOT}/FileSets" "${INSTALL_ROOT}/FileSets"
  fi
}

perform_install() {
  helper_begin
  register_package_dependencies

  install_payload

  helper_install_service "${SERVICE_NAME}" "${SERVICE_INSTALL_DIR}"

  for entry in "${SETTINGS_DEFINITIONS[@]}"; do
    IFS='|' read -r path type default description <<<"${entry}"
    if ! helper_register_settings "${path}" "${type}" "${default}" "${description}"; then
      die "helper_register_settings konnte Einstellung ${path} nicht registrieren"
    fi
  done

  helper_end
  log INFO "Installation abgeschlossen"
}

perform_uninstall() {
  helper_begin
  register_package_dependencies

  if ! helper_unregister_settings "${SETTINGS_BASE_PATH}"; then
    log WARN "helper_unregister_settings konnte Einstellungen nicht deregistrieren"
  fi
  helper_uninstall_service "${SERVICE_NAME}"

  if [[ -d "${INSTALL_ROOT}" ]]; then
    log INFO "Entferne Installationsverzeichnis ${INSTALL_ROOT}"
    rm -rf "${INSTALL_ROOT}"
  fi

  helper_end
  log INFO "Deinstallation abgeschlossen"
}

perform_status() {
  helper_begin
  register_package_dependencies
  helper_print_service_status "${SERVICE_NAME}"
  helper_end
}

usage() {
  cat <<USAGE
Verwendung: ${0##*/} <install|uninstall|status>
USAGE
}

main() {
  local action="${1:-install}"

  source_setup_helper

  case "${action}" in
    install)
      perform_install
      ;;
    uninstall)
      perform_uninstall
      ;;
    status)
      perform_status
      ;;
    *)
      usage
      exit 1
      ;;
  esac
}

main "$@"
