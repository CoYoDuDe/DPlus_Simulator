#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="${SCRIPT_DIR}"
INSTALL_ROOT="${INSTALL_ROOT:-/opt/dplus_sim}"
SERVICE_NAME="com.coyodude.dplussim"
SERVICE_INSTALL_DIR="${INSTALL_ROOT}/services/${SERVICE_NAME}"
DEFAULT_HELPER_INCLUDE="${PROJECT_ROOT}/SetupHelper/HelperResources/IncludeHelpers"
HELPER_RESOURCE="${HELPER_RESOURCE:-${DEFAULT_HELPER_INCLUDE}}"
SETTINGS_BASE_PATH="/Settings/Devices/DPlusSim"
PACKAGE_DEPENDENCIES_FILE="${PROJECT_ROOT}/packageDependencies"

filesUpdated=false
servicesUpdated=false
dbusSettingsUpdated=false
declare -a _dbus_settings_entries=()
_dbus_settings_json=""

log() {
  local level="${1^^}"
  shift
  if declare -F logMessage >/dev/null; then
    logMessage "${level}" "$*"
    return
  fi
  printf '[%s] %s\n' "${level}" "$*"
}

die() {
  log ERROR "$*"
  exit 1
}

copy_tree() {
  local src="$1"
  local dest="$2"
  mkdir -p "${dest}"
  if command -v rsync >/dev/null 2>&1; then
    rsync -a --delete "${src}/" "${dest}/"
  else
    if [[ -d "${dest}" ]]; then
      find "${dest}" -mindepth 1 -exec rm -rf {} +
    fi
    tar -C "${src}" -cf - . | tar -C "${dest}" -xf -
  fi
}
call_helper_function_if_available() {
  local fn="$1"
  shift || true
  if ! declare -F "${fn}" >/dev/null; then
    return 127
  fi

  # Temporär striktes Fehler-Handling deaktivieren, um alternative Aufrufe
  # ausprobieren zu können, ohne das Skript sofort abzubrechen.
  set +e
  "${fn}" "$@"
  local status=$?
  set -e
  return ${status}
}

define_builtin_helper_fallback() {
  if [[ -n "${__DPLUS_HELPER_FALLBACK_DEFINED:-}" ]]; then
    return
  fi

  __DPLUS_HELPER_FALLBACK_DEFINED=1
  log WARN "Keine externen SetupHelper-Ressourcen gefunden – verwende integrierten Fallback"

  __dplus_helper_project_root="${PROJECT_ROOT:-$(pwd)}"
  __dplus_helper_state_dir="${__dplus_helper_project_root}/SetupHelper/.helper_state"
  mkdir -p "${__dplus_helper_state_dir}"

  logMessage() {
    local level="${1:-INFO}"
    shift || true
    local timestamp
    timestamp="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
    printf '[HELPER][%s][%s] %s\n' "${timestamp}" "${level^^}" "$*"
  }

  helper_begin() {
    logMessage INFO "Starte Helper-Sitzung"
    mkdir -p "${__dplus_helper_state_dir}"
    return 0
  }

  helper_end() {
    logMessage INFO "Beende Helper-Sitzung"
    return 0
  }

  beginScript() {
    helper_begin
  }

  endScript() {
    helper_end
  }

  helper_enable_dependency_conflict_checks() {
    logMessage INFO "Aktiviere Konfliktprüfungen (Fallback-No-Op)"
    return 0
  }

  helper_enable_package_conflict_checks() {
    helper_enable_dependency_conflict_checks
  }

  __dplus_helper_store_dependencies() {
    local src_file="$1"
    local dest_file="${__dplus_helper_state_dir}/packageDependencies"
    if [[ ! -r "${src_file}" ]]; then
      logMessage ERROR "packageDependencies-Datei ${src_file} ist nicht lesbar"
      return 1
    fi
    cp "${src_file}" "${dest_file}"
    logMessage INFO "Registriere packageDependencies aus ${src_file}"
    return 0
  }

  helper_register_package_dependencies() {
    __dplus_helper_store_dependencies "$1"
  }

  helper_use_package_dependencies() {
    __dplus_helper_store_dependencies "$1"
  }

  helper_runtime_notice() {
    logMessage INFO "$*"
  }

  __dplus_helper_service_state_dir="${__dplus_helper_state_dir}/services"
  mkdir -p "${__dplus_helper_service_state_dir}"

  __dplus_helper_service_link_dir="${INSTALL_ROOT:-${__dplus_helper_project_root}/.install}/service-links"
  mkdir -p "${__dplus_helper_service_link_dir}"

  __dplus_helper_mark_service_installed() {
    local service_name="$1"
    local service_dir="$2"
    ln -sfn "${service_dir}" "${__dplus_helper_service_state_dir}/${service_name}"
    ln -sfn "${service_dir}" "${__dplus_helper_service_link_dir}/${service_name}"
    logMessage INFO "Dienst ${service_name} wurde für die lokale Installation verknüpft"
  }

  helper_install_service() {
    local service_name="$1"
    local service_dir="$2"
    if [[ -z "${service_name}" || -z "${service_dir}" ]]; then
      logMessage ERROR "Ungültige Parameter für helper_install_service"
      return 1
    fi
    if [[ ! -d "${service_dir}" ]]; then
      logMessage ERROR "Dienstverzeichnis ${service_dir} existiert nicht"
      return 1
    fi
    __dplus_helper_mark_service_installed "${service_name}" "${service_dir}"
    return 0
  }

  installService() {
    helper_install_service "$@"
  }

  helper_uninstall_service() {
    local service_name="$1"
    rm -f "${__dplus_helper_service_state_dir}/${service_name}"
    rm -f "${__dplus_helper_service_link_dir}/${service_name}"
    logMessage INFO "Dienst ${service_name} wurde aus der lokalen Installation entfernt"
    return 0
  }

  removeService() {
    helper_uninstall_service "$@"
  }

  helper_print_service_status() {
    local service_name="$1"
    if [[ -L "${__dplus_helper_service_state_dir}/${service_name}" ]]; then
      printf 'Dienst %s ist lokal verknüpft.\n' "${service_name}"
    else
      printf 'Dienst %s ist nicht verknüpft.\n' "${service_name}"
    fi
  }

  serviceIsUp() {
    local service_name="$1"
    if [[ -L "${__dplus_helper_service_state_dir}/${service_name}" ]]; then
      return 0
    fi
    return 1
  }

  __dplus_helper_settings_state_dir="${__dplus_helper_state_dir}/dbus_settings"
  mkdir -p "${__dplus_helper_settings_state_dir}"

  DbusSettingsList() {
    printf '%s\n' "$@"
  }

  __dplus_helper_store_settings_lines() {
    local dest_file="$1"
    shift || true
    printf '%s\n' "$@" > "${dest_file}"
  }

  addAllDbusSettingsFromFile() {
    local settings_file="$1"
    if [[ ! -r "${settings_file}" ]]; then
      logMessage ERROR "D-Bus-Definition ${settings_file} ist nicht lesbar"
      return 1
    fi
    local dest_file="${__dplus_helper_settings_state_dir}/registered_from_file.list"
    cp "${settings_file}" "${dest_file}"
    logMessage INFO "Registriere D-Bus-Einstellungen aus ${settings_file}"
    return 0
  }

  addAllDbusSettings() {
    if [[ $# -eq 1 && -f "$1" ]]; then
      addAllDbusSettingsFromFile "$1"
      return $?
    fi
    local dest_file="${__dplus_helper_settings_state_dir}/registered_inline.list"
    __dplus_helper_store_settings_lines "${dest_file}" "$@"
    logMessage INFO "Registriere D-Bus-Einstellungen aus Argumentliste"
    return 0
  }

  removeDbusSettingsFromFile() {
    local settings_file="$1"
    if [[ -f "${__dplus_helper_settings_state_dir}/registered_from_file.list" ]]; then
      rm -f "${__dplus_helper_settings_state_dir}/registered_from_file.list"
      logMessage INFO "Deregistriere D-Bus-Einstellungen (Datei ${settings_file})"
    else
      logMessage INFO "Keine registrierten D-Bus-Einstellungen aus Datei vorhanden"
    fi
    return 0
  }

  removeDbusSettings() {
    if [[ $# -eq 1 && -f "$1" ]]; then
      removeDbusSettingsFromFile "$1"
      return 0
    fi
    rm -f "${__dplus_helper_settings_state_dir}/registered_inline.list"
    logMessage INFO "Deregistriere D-Bus-Einstellungen aus Argumentliste"
    return 0
  }

  helper_register_settings_with_metadata() {
    local dest_file="${__dplus_helper_settings_state_dir}/metadata.list"
    cat > "${dest_file}"
    logMessage INFO "Registriere Einstellungen inklusive Metadaten"
    return 0
  }

  helper_register_settings() {
    local dest_file="${__dplus_helper_settings_state_dir}/simple.list"
    cat > "${dest_file}"
    logMessage INFO "Registriere Einstellungen ohne Metadaten"
    return 0
  }

  helper_unregister_settings() {
    local base_path="$1"
    rm -f "${__dplus_helper_settings_state_dir}/"*.list 2>/dev/null || true
    logMessage INFO "Deregistriere Einstellungen unter Basis ${base_path}"
    return 0
  }
}

source_helper_resources() {
  local -a search_candidates=()
  local candidate=""

  if [[ -n "${SETUP_HELPER_ROOT:-}" ]]; then
    if [[ -d "${SETUP_HELPER_ROOT}" ]]; then
      search_candidates+=("${SETUP_HELPER_ROOT}/HelperResources")
    elif [[ -f "${SETUP_HELPER_ROOT}" ]]; then
      search_candidates+=("${SETUP_HELPER_ROOT}")
    fi
  fi

  if [[ -n "${HELPER_RESOURCE:-}" ]]; then
    search_candidates+=("${HELPER_RESOURCE}")
  fi

  search_candidates+=(
    "${PROJECT_ROOT}/SetupHelper/HelperResources"
    "/data/SetupHelper/HelperResources"
    "/opt/venus/SetupHelper/HelperResources"
    "/opt/venusOS/SetupHelper/HelperResources"
    "/usr/share/SetupHelper/HelperResources"
  )

  local helper_cmd=""
  for helper_cmd in setuphelper SetupHelper helperctl; do
    if command -v "${helper_cmd}" >/dev/null 2>&1; then
      local helper_bin
      helper_bin="$(command -v "${helper_cmd}")"
      local helper_root
      helper_root="$(cd "$(dirname "${helper_bin}")/.." && pwd -P 2>/dev/null)"
      if [[ -n "${helper_root}" ]]; then
        search_candidates+=("${helper_root}/HelperResources")
      fi
    fi
  done

  for candidate in "${search_candidates[@]}"; do
    [[ -z "${candidate}" ]] && continue

    if [[ -f "${candidate}" && -r "${candidate}" ]]; then
      # shellcheck disable=SC1090
      source "${candidate}"
      return
    fi

    if [[ -d "${candidate}" ]]; then
      if [[ -r "${candidate}/forSetupScript" ]]; then
        # shellcheck disable=SC1090
        source "${candidate}/forSetupScript"
        return
      fi

      if [[ -r "${candidate}/IncludeHelpers" ]]; then
        # shellcheck disable=SC1090
        source "${candidate}/IncludeHelpers"
        return
      fi

      local -a helper_files=(
        "${candidate}/CommonResources"
        "${candidate}/ServiceResources"
        "${candidate}/DbusSettingsResources"
      )

      local file=""
      local missing=0
      for file in "${helper_files[@]}"; do
        if [[ -r "${file}" ]]; then
          # shellcheck disable=SC1090
          source "${file}"
        else
          missing=1
          break
        fi
      done

      if (( missing == 0 )); then
        return
      fi
    fi
  done

  define_builtin_helper_fallback
}

begin_helper_session() {
  if declare -F beginScript >/dev/null; then
    beginScript
    return
  fi
  if declare -F helper_begin >/dev/null; then
    helper_begin
  fi
}

end_helper_session() {
  if declare -F endScript >/dev/null; then
    endScript
    return
  fi
  if declare -F helper_end >/dev/null; then
    helper_end
  fi
}

install_service() {
  if call_helper_function_if_available installService "${SERVICE_NAME}" "${SERVICE_INSTALL_DIR}"; then
    return
  fi
  if call_helper_function_if_available helper_install_service "${SERVICE_NAME}" "${SERVICE_INSTALL_DIR}"; then
    return
  fi
  die "SetupHelper stellt keine Funktion zum Installieren des Dienstes bereit"
}

remove_service() {
  if call_helper_function_if_available removeService "${SERVICE_NAME}"; then
    return
  fi
  if call_helper_function_if_available helper_uninstall_service "${SERVICE_NAME}"; then
    return
  fi
  die "SetupHelper stellt keine Funktion zum Entfernen des Dienstes bereit"
}

build_dbus_settings_entries() {
  local list_path="$1"
  if [[ ! -f "${list_path}" ]]; then
    die "settingsList ${list_path} nicht gefunden"
  fi
  mapfile -t _dbus_settings_entries < "${list_path}"

  local trimmed_entries=()
  local entry=""
  for entry in "${_dbus_settings_entries[@]}"; do
    local trimmed="${entry}"
    trimmed="${trimmed#${trimmed%%[![:space:]]*}}"
    trimmed="${trimmed%${trimmed##*[![:space:]]}}"
    if [[ -n "${trimmed}" ]]; then
      trimmed_entries+=("${trimmed}")
    fi
  done
  _dbus_settings_entries=("${trimmed_entries[@]}")

  local json_payload="["
  local first=true
  for entry in "${_dbus_settings_entries[@]}"; do
    if [[ "${first}" == true ]]; then
      json_payload+="${entry}"
      first=false
    else
      json_payload+=",${entry}"
    fi
  done
  json_payload+="]"
  _dbus_settings_json="${json_payload}"
}

register_dbus_settings() {
  local list_path="${PROJECT_ROOT}/settingsList"
  local helper_json_file="${PROJECT_ROOT}/DbusSettingsList"
  local temp_json_file=""
  build_dbus_settings_entries "${list_path}"

  if [[ -f "${helper_json_file}" ]]; then
    if call_helper_function_if_available addAllDbusSettingsFromFile "${helper_json_file}"; then
      dbusSettingsUpdated=true
      return
    fi
  elif [[ -n "${_dbus_settings_json}" ]]; then
    temp_json_file="$(mktemp "${TMPDIR:-/tmp}/DbusSettingsList.XXXXXX.json")"
    printf '%s\n' "${_dbus_settings_json}" > "${temp_json_file}"
    if call_helper_function_if_available addAllDbusSettingsFromFile "${temp_json_file}"; then
      dbusSettingsUpdated=true
      rm -f "${temp_json_file}"
      return
    fi
  fi

  if [[ -n "${temp_json_file}" ]]; then
    rm -f "${temp_json_file}"
  fi

  if call_helper_function_if_available addAllDbusSettingsFromFile "${list_path}"; then
    dbusSettingsUpdated=true
    return
  fi

  if declare -F addAllDbusSettings >/dev/null; then
    local helper_list_backup=""
    local helper_list_created=false

    if [[ ${#_dbus_settings_entries[@]} -gt 0 ]]; then
      if [[ -f "${helper_json_file}" ]]; then
        helper_list_backup="$(mktemp "${TMPDIR:-/tmp}/DbusSettingsList.backup.XXXXXX")"
        cp -f "${helper_json_file}" "${helper_list_backup}"
      fi
      printf '%s\n' "${_dbus_settings_entries[@]}" > "${helper_json_file}"
      helper_list_created=true
    fi

    if call_helper_function_if_available addAllDbusSettings; then
      dbusSettingsUpdated=true
      if [[ -n "${helper_list_backup}" ]]; then
        mv -f "${helper_list_backup}" "${helper_json_file}"
      elif [[ "${helper_list_created}" == true ]]; then
        rm -f "${helper_json_file}"
      fi
      return
    fi

    if [[ -n "${helper_list_backup}" ]]; then
      mv -f "${helper_list_backup}" "${helper_json_file}"
    elif [[ "${helper_list_created}" == true ]]; then
      rm -f "${helper_json_file}"
    fi

    local settings_list_output=""
    if declare -F DbusSettingsList >/dev/null; then
      set +e
      settings_list_output="$(DbusSettingsList "${_dbus_settings_entries[@]}")"
      local list_status=$?
      set -e
      if [[ ${list_status} -eq 0 && -n "${settings_list_output}" ]]; then
        call_helper_function_if_available addAllDbusSettings "${settings_list_output}" && {
          dbusSettingsUpdated=true
          return
        }
      fi
    fi

    if [[ -n "${_dbus_settings_json}" ]]; then
      if call_helper_function_if_available addAllDbusSettings "${_dbus_settings_json}"; then
        dbusSettingsUpdated=true
        return
      fi
    fi

    if call_helper_function_if_available addAllDbusSettings "${list_path}"; then
      dbusSettingsUpdated=true
      return
    fi

    if call_helper_function_if_available addAllDbusSettings "${_dbus_settings_entries[@]}"; then
      dbusSettingsUpdated=true
      return
    fi
  fi

  if declare -F helper_register_settings_with_metadata >/dev/null || declare -F helper_register_settings >/dev/null; then
    if register_settings_definitions; then
      dbusSettingsUpdated=true
      return
    fi
  fi

  die "SetupHelper stellt keine geeignete Funktion zum Registrieren der Einstellungen bereit"
}

unregister_dbus_settings() {
  local list_path="${PROJECT_ROOT}/settingsList"
  build_dbus_settings_entries "${list_path}"

  if call_helper_function_if_available removeDbusSettingsFromFile "${list_path}"; then
    dbusSettingsUpdated=true
    return
  fi

  if declare -F removeDbusSettings >/dev/null; then
    local helper_json_file="${PROJECT_ROOT}/DbusSettingsList"
    local helper_list_backup=""
    local helper_list_created=false

    if [[ ${#_dbus_settings_entries[@]} -gt 0 ]]; then
      if [[ -f "${helper_json_file}" ]]; then
        helper_list_backup="$(mktemp "${TMPDIR:-/tmp}/DbusSettingsList.backup.XXXXXX")"
        cp -f "${helper_json_file}" "${helper_list_backup}"
      fi
      printf '%s\n' "${_dbus_settings_entries[@]}" > "${helper_json_file}"
      helper_list_created=true
    fi

    if call_helper_function_if_available removeDbusSettings; then
      dbusSettingsUpdated=true
      if [[ -n "${helper_list_backup}" ]]; then
        mv -f "${helper_list_backup}" "${helper_json_file}"
      elif [[ "${helper_list_created}" == true ]]; then
        rm -f "${helper_json_file}"
      fi
      return
    fi

    if [[ -n "${helper_list_backup}" ]]; then
      mv -f "${helper_list_backup}" "${helper_json_file}"
    elif [[ "${helper_list_created}" == true ]]; then
      rm -f "${helper_json_file}"
    fi

    local settings_list_output=""
    if declare -F DbusSettingsList >/dev/null; then
      set +e
      settings_list_output="$(DbusSettingsList "${_dbus_settings_entries[@]}")"
      local list_status=$?
      set -e
      if [[ ${list_status} -eq 0 && -n "${settings_list_output}" ]]; then
        call_helper_function_if_available removeDbusSettings "${settings_list_output}" && {
          dbusSettingsUpdated=true
          return
        }
      fi
    fi

    if call_helper_function_if_available removeDbusSettings "${list_path}"; then
      dbusSettingsUpdated=true
      return
    fi

    if call_helper_function_if_available removeDbusSettings "${_dbus_settings_entries[@]}"; then
      dbusSettingsUpdated=true
      return
    fi
  fi

  if declare -F helper_unregister_settings >/dev/null; then
    if helper_unregister_settings "${SETTINGS_BASE_PATH}"; then
      dbusSettingsUpdated=true
      return
    fi
  fi

  log WARN "Einstellungsderegistrierung konnte nicht über SetupHelper durchgeführt werden"
}

service_is_up() {
  if declare -F serviceIsUp >/dev/null; then
    set +e
    serviceIsUp "${SERVICE_NAME}"
    local status=$?
    set -e
    return ${status}
  fi

  if declare -F helper_print_service_status >/dev/null; then
    helper_print_service_status "${SERVICE_NAME}"
    return 0
  fi

  log INFO "Statusabfrage für Dienst ${SERVICE_NAME} nicht verfügbar"
  return 1
}

register_package_dependencies() {
  if [[ ! -f "${PACKAGE_DEPENDENCIES_FILE}" ]]; then
    log WARN "packageDependencies-Datei fehlt, überspringe Registrierung"
    return
  fi

  if declare -F helper_enable_dependency_conflict_checks >/dev/null; then
    helper_enable_dependency_conflict_checks
  elif declare -F helper_enable_package_conflict_checks >/dev/null; then
    helper_enable_package_conflict_checks
  else
    log WARN "SetupHelper bietet keine Konfliktprüfung, Registrierung läuft ohne zusätzliche Prüfung"
  fi

  if declare -F helper_register_package_dependencies >/dev/null; then
    helper_register_package_dependencies "${PACKAGE_DEPENDENCIES_FILE}"
  elif declare -F helper_use_package_dependencies >/dev/null; then
    helper_use_package_dependencies "${PACKAGE_DEPENDENCIES_FILE}"
  else
    die "SetupHelper unterstützt das Registrieren von packageDependencies nicht"
  fi
}

register_settings_definitions() {
  local -a settings_definitions=(
    "/Settings/Devices/DPlusSim/GpioPin|i|17|GPIO-Pin, der die simulierte D+-Leitung schaltet."
    "/Settings/Devices/DPlusSim/TargetVoltage|f|3.3|Zielspannung in Volt, die durch die Simulation angestrebt wird."
    "/Settings/Devices/DPlusSim/Hysteresis|f|0.1|Hystereseband in Volt, bevor der GPIO neu geschaltet wird."
    "/Settings/Devices/DPlusSim/ActivationDelaySeconds|f|2.0|Verzögerung in Sekunden, bevor der GPIO bei steigender Spannung eingeschaltet wird."
    "/Settings/Devices/DPlusSim/DeactivationDelaySeconds|f|5.0|Verzögerung in Sekunden, bevor der GPIO bei fallender Spannung ausgeschaltet wird."
    "/Settings/Devices/DPlusSim/OnVoltage|f|3.35|Spannung, ab der die D+-Simulation aktiviert werden soll."
    "/Settings/Devices/DPlusSim/OffVoltage|f|3.25|Spannung, unter der die D+-Simulation deaktiviert wird."
    "/Settings/Devices/DPlusSim/OnDelaySec|f|2.0|Verzögerung in Sekunden bis zum Einschalten, sobald alle Bedingungen erfüllt sind."
    "/Settings/Devices/DPlusSim/OffDelaySec|f|5.0|Verzögerung in Sekunden bis zum Ausschalten, wenn die Bedingungen entfallen."
    "/Settings/Devices/DPlusSim/UseIgnition|b|0|Aktiviert die Abhängigkeit vom Zündplus-Eingang."
    "/Settings/Devices/DPlusSim/IgnitionGpio|i|4|GPIO-Pin, an dem das Zündplus-Signal eingelesen wird."
    "/Settings/Devices/DPlusSim/IgnitionPull|s|down|Pull-Up/-Down-Konfiguration für den Zündplus-Eingang (up/down/none)."
    "/Settings/Devices/DPlusSim/ForceOn|b|0|Erzwingt dauerhaft ein aktives D+-Signal."
    "/Settings/Devices/DPlusSim/ForceOff|b|0|Erzwingt dauerhaft ein deaktiviertes D+-Signal."
    "/Settings/Devices/DPlusSim/StatusPublishInterval|f|2.0|Intervall in Sekunden zur Veröffentlichung des Status über D-Bus-Signale."
    "/Settings/Devices/DPlusSim/DbusBus|s|system|Zu verwendender D-Bus (system oder session)."
    "/Settings/Devices/DPlusSim/ServicePath|s|com.victronenergy.battery|D-Bus-Service, aus dem die Spannung gelesen wird."
    "/Settings/Devices/DPlusSim/VoltagePath|s|/Dc/0/Voltage|Objektpfad des Spannungswertes."
    "/Settings/Devices/DPlusSim/OutputMode|s|gpio|Steuerungsmodus für den D+-Ausgang (gpio oder relay)."
    "/Settings/Devices/DPlusSim/RelayChannel|s|4brelays/0|Ausgewählter Relay-Kanal aus der gpiosetup-Konfiguration."
  )

  local metadata_payload=""
  local fallback_payload=""

  while IFS='|' read -r path type default desc; do
    local fallback_default="${default}"
    local metadata_default="${default}"

    if [[ "${type}" == "b" ]]; then
      case "${default}" in
        1|true|TRUE)
          fallback_default="1"
          metadata_default="true"
          ;;
        0|false|FALSE|'')
          fallback_default="0"
          metadata_default="false"
          ;;
        *)
          die "Ungültiger Standardwert ${default} für boolesche Einstellung ${path}"
          ;;
      esac
    fi

    metadata_payload+="${path}|${type}|${metadata_default}|${desc}"$'\n'
    fallback_payload+="${path} ${type} ${fallback_default}"$'\n'
  done < <(printf '%s\n' "${settings_definitions[@]}")

  if declare -F helper_register_settings_with_metadata >/dev/null; then
    helper_register_settings_with_metadata <<EOF
${metadata_payload%$'\n'}
EOF
    return
  fi

  helper_register_settings <<EOF
${fallback_payload%$'\n'}
EOF
}


install_payload() {
  log INFO "Installationsdateien nach ${INSTALL_ROOT} kopieren"
  mkdir -p "${INSTALL_ROOT}"

  copy_tree "${PROJECT_ROOT}/src" "${INSTALL_ROOT}/src"
  copy_tree "${PROJECT_ROOT}/services" "${INSTALL_ROOT}/services"

  install -m 644 "${PROJECT_ROOT}/src/settings_schema.json" "${INSTALL_ROOT}/settings_schema.json"
  install -m 644 "${PROJECT_ROOT}/version" "${INSTALL_ROOT}/version"
  install -m 644 "${PROJECT_ROOT}/packageDependencies" "${INSTALL_ROOT}/packageDependencies"
  install -m 644 "${PROJECT_ROOT}/gitHubInfo" "${INSTALL_ROOT}/gitHubInfo"
  install -m 644 "${PROJECT_ROOT}/settingsList" "${INSTALL_ROOT}/settingsList"

  if [[ -d "${PROJECT_ROOT}/FileSets" ]]; then
    copy_tree "${PROJECT_ROOT}/FileSets" "${INSTALL_ROOT}/FileSets"
  fi
}

perform_install() {
  filesUpdated=false
  servicesUpdated=false
  dbusSettingsUpdated=false

  begin_helper_session
  register_package_dependencies

  install_payload
  filesUpdated=true

  install_service
  servicesUpdated=true

  register_dbus_settings

  end_helper_session
  log INFO "Installation abgeschlossen"
}

perform_uninstall() {
  filesUpdated=false
  servicesUpdated=false
  dbusSettingsUpdated=false

  begin_helper_session
  register_package_dependencies

  unregister_dbus_settings

  remove_service
  servicesUpdated=true

  if [[ -d "${INSTALL_ROOT}" ]]; then
    log INFO "Entferne Installationsverzeichnis ${INSTALL_ROOT}"
    rm -rf "${INSTALL_ROOT}"
    filesUpdated=true
  fi

  end_helper_session
  log INFO "Deinstallation abgeschlossen"
}

perform_status() {
  filesUpdated=false
  servicesUpdated=false
  dbusSettingsUpdated=false

  begin_helper_session
  register_package_dependencies

  local status_reported=false
  if declare -F serviceIsUp >/dev/null; then
    if service_is_up; then
      log INFO "Dienst ${SERVICE_NAME} ist aktiv"
    else
      log WARN "Dienst ${SERVICE_NAME} ist nicht aktiv"
    fi
    status_reported=true
  fi

  if [[ "${status_reported}" == false ]] && declare -F helper_print_service_status >/dev/null; then
    helper_print_service_status "${SERVICE_NAME}"
    status_reported=true
  fi

  if [[ "${status_reported}" == false ]]; then
    log WARN "Keine Statusfunktion für Dienst ${SERVICE_NAME} verfügbar"
  fi

  end_helper_session
}

usage() {
  cat <<USAGE
Verwendung: ${0##*/} <install|uninstall|status>
USAGE
}

main() {
  local cli_action="${1:-}"
  local normalized_cli=""

  if [[ -n "${cli_action}" ]]; then
    case "${cli_action}" in
      install|uninstall|status)
        normalized_cli="${cli_action}"
        ;;
      -h|--help)
        usage
        return 0
        ;;
      *)
        usage
        return 1
        ;;
    esac
  fi

  local helper_action="${scriptAction:-}"
  if [[ -z "${helper_action}" ]]; then
    case "${normalized_cli:-install}" in
      install)
        helper_action="INSTALL"
        normalized_cli="install"
        ;;
      uninstall)
        helper_action="UNINSTALL"
        ;;
      status)
        helper_action="CHECK"
        ;;
    esac
  else
    local expected_from_cli=""
    case "${normalized_cli}" in
      install) expected_from_cli="INSTALL" ;;
      uninstall) expected_from_cli="UNINSTALL" ;;
      status) expected_from_cli="CHECK" ;;
    esac

    if [[ -n "${expected_from_cli}" && "${helper_action}" != "${expected_from_cli}" ]]; then
      log WARN "scriptAction ${helper_action} stimmt nicht mit der CLI-Aktion ${normalized_cli} überein; verwende CLI-Aktion"
      helper_action="${expected_from_cli}"
    fi

    if [[ -z "${normalized_cli}" ]]; then
      case "${helper_action}" in
        INSTALL) normalized_cli="install" ;;
        UNINSTALL) normalized_cli="uninstall" ;;
        CHECK) normalized_cli="status" ;;
        *)
          log WARN "Unbekannte scriptAction ${helper_action}, verwende INSTALL"
          helper_action="INSTALL"
          normalized_cli="install"
          ;;
      esac
    fi
  fi

  scriptAction="${helper_action}"

  source_helper_resources

  case "${scriptAction}" in
    INSTALL)
      perform_install
      ;;
    UNINSTALL)
      perform_uninstall
      ;;
    CHECK)
      perform_status
      ;;
    *)
      log ERROR "Unbekannte scriptAction ${scriptAction}"
      usage
      return 1
      ;;
  esac
}

if [[ -z "${DPLUS_SIMULATOR_SKIP_MAIN:-}" ]]; then
  main "$@"
fi
