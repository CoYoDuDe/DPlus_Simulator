#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="${SCRIPT_DIR}"
INSTALL_ROOT="${INSTALL_ROOT:-/opt/dplus_sim}"
SERVICE_NAME="com.coyodude.dplussim"
SERVICE_INSTALL_DIR="${INSTALL_ROOT}/services/${SERVICE_NAME}"
DEFAULT_HELPER_INCLUDE="${PROJECT_ROOT}/SetupHelper/HelperResources/IncludeHelpers"
HELPER_RESOURCE="${HELPER_RESOURCE:-${DEFAULT_HELPER_INCLUDE}}"
SETTINGS_BASE_PATH="/Settings/Devices/DPlusSim"
PACKAGE_DEPENDENCIES_FILE="${PROJECT_ROOT}/packageDependencies"

REQUIRED_SETUP_HELPER_VERSION="8.10"
SETUP_HELPER_DETECTED_ROOT=""
SETUP_HELPER_VERSION_RAW=""
SETUP_HELPER_VERSION_NORMALIZED=""
RESOLVED_CLI_ACTION=""

filesUpdated=false
servicesUpdated=false
dbusSettingsUpdated=false
declare -a _dbus_settings_entries=()
_dbus_settings_multiline=""
DBUS_SETTINGS_FILENAME="DbusSettingsList"
DBUS_SETTINGS_STAGING_FILE="${PROJECT_ROOT}/${DBUS_SETTINGS_FILENAME}"
DBUS_SETTINGS_PERSISTENT_FILE="${INSTALL_ROOT}/${DBUS_SETTINGS_FILENAME}"
DBUS_SETTINGS_STAGING_BACKUP=""
DBUS_SETTINGS_PERSISTENT_BACKUP=""
DBUS_SETTINGS_STAGING_CREATED=false
DBUS_SETTINGS_PERSISTENT_UPDATED=false
DBUS_SETTINGS_OPERATION=""
LAST_PACKAGE_DEPENDENCY_CHECK_STATUS=""
LAST_PACKAGE_DEPENDENCY_CHECK_ACTION=""
LAST_PACKAGE_DEPENDENCY_CHECK_INSTALL_FAILED=""
LAST_PACKAGE_DEPENDENCY_CHECK_FAIL_MESSAGE=""
LAST_PACKAGE_DEPENDENCY_CHECK_CONFLICT=false

log() {
  local level="${1^^}"
  shift
  if declare -F logMessage >/dev/null; then
    logMessage "${level}" "$*"
    return
  fi
  printf '[%s] %s\n' "${level}" "$*"
}

die() {
  log ERROR "$*"
  exit 1
}

trim_whitespace() {
  local value="${1:-}"
  value="${value#${value%%[![:space:]]*}}"
  value="${value%${value##*[![:space:]]}}"
  printf '%s' "${value}"
}

normalize_version_string() {
  local raw="$(trim_whitespace "${1:-}")"
  raw="${raw#v}"
  raw="${raw#V}"
  raw="${raw%%[^0-9.]*}"
  raw="$(trim_whitespace "${raw}")"
  printf '%s' "${raw}"
}

resolve_setup_helper_root_from_candidate() {
  local candidate="$1"
  local base=""

  if [[ -z "${candidate}" ]]; then
    return 1
  fi

  if [[ -f "${candidate}" ]]; then
    base="$(cd "$(dirname "${candidate}")" && pwd -P 2>/dev/null)" || return 1
  else
    base="$(cd "${candidate}" && pwd -P 2>/dev/null)" || return 1
  fi

  if [[ -z "${base}" ]]; then
    return 1
  fi

  if [[ "${base##*/}" == "HelperResources" ]]; then
    base="$(cd "${base}/.." && pwd -P 2>/dev/null)" || return 1
  fi

  if [[ -n "${base}" ]]; then
    printf '%s\n' "${base}"
    return 0
  fi

  return 1
}

remember_setup_helper_root() {
  local candidate="$1"
  local resolved=""

  if [[ -z "${candidate}" ]]; then
    return
  fi

  if resolved="$(resolve_setup_helper_root_from_candidate "${candidate}")"; then
    if [[ -n "${resolved}" ]]; then
      SETUP_HELPER_DETECTED_ROOT="${resolved}"
    fi
  fi
}

detect_setuphelper_version() {
  local -a version_candidates=()
  local helper_cmd=""
  local candidate=""

  if [[ -n "${SETUP_HELPER_DETECTED_ROOT:-}" ]]; then
    version_candidates+=("${SETUP_HELPER_DETECTED_ROOT}/version")
  fi

  for helper_cmd in setuphelper SetupHelper helperctl; do
    if command -v "${helper_cmd}" >/dev/null 2>&1; then
      local helper_bin=""
      helper_bin="$(command -v "${helper_cmd}")"
      local helper_root=""
      helper_root="$(cd "$(dirname "${helper_bin}")/.." && pwd -P 2>/dev/null)" || helper_root=""
      if [[ -n "${helper_root}" ]]; then
        version_candidates+=("${helper_root}/version")
      fi
    fi
  done

  version_candidates+=(
    "/data/SetupHelper/version"
    "/opt/venus/SetupHelper/version"
    "/opt/venusOS/SetupHelper/version"
    "/usr/share/SetupHelper/version"
    "${PROJECT_ROOT}/SetupHelper/version"
  )

  for candidate in "${version_candidates[@]}"; do
    [[ -z "${candidate}" ]] && continue

    if [[ -f "${candidate}" ]]; then
      local raw_version
      raw_version="$(<"${candidate}")"
      raw_version="${raw_version//$'\r'/}"
      raw_version="${raw_version//$'\n'/}"
      raw_version="$(trim_whitespace "${raw_version}")"

      if [[ -n "${raw_version}" ]]; then
        SETUP_HELPER_VERSION_RAW="${raw_version}"
        local normalized=""
        normalized="$(normalize_version_string "${raw_version}")"
        if [[ -n "${normalized}" ]]; then
          SETUP_HELPER_VERSION_NORMALIZED="${normalized}"
          return 0
        fi
      fi
    fi
  done

  return 1
}

version_ge() {
  local current="$1"
  local required="$2"
  local IFS='.'
  local -a current_parts=()
  local -a required_parts=()

  read -r -a current_parts <<< "${current}"
  read -r -a required_parts <<< "${required}"

  local max_len="${#current_parts[@]}"
  if (( ${#required_parts[@]} > max_len )); then
    max_len="${#required_parts[@]}"
  fi

  local idx
  for (( idx = 0; idx < max_len; idx++ )); do
    local current_value="${current_parts[idx]:-0}"
    local required_value="${required_parts[idx]:-0}"

    current_value="${current_value//[^0-9]/}"
    required_value="${required_value//[^0-9]/}"

    if (( 10#${current_value:-0} > 10#${required_value:-0} )); then
      return 0
    fi

    if (( 10#${current_value:-0} < 10#${required_value:-0} )); then
      return 1
    fi
  done

  return 0
}

require_setuphelper_version() {
  local required_version="$1"

  if [[ -z "${required_version}" ]]; then
    return
  fi

  if ! detect_setuphelper_version; then
    die "SetupHelper-Version konnte nicht ermittelt werden. Bitte installieren Sie SetupHelper >= ${required_version}."
  fi

  if [[ -z "${SETUP_HELPER_VERSION_NORMALIZED}" ]]; then
    die "SetupHelper-Version konnte nicht interpretiert werden."
  fi

  if ! version_ge "${SETUP_HELPER_VERSION_NORMALIZED}" "${required_version}"; then
    die "Gefundene SetupHelper-Version ${SETUP_HELPER_VERSION_RAW:-${SETUP_HELPER_VERSION_NORMALIZED}} ist kleiner als erforderlich (${required_version})."
  fi

  log INFO "SetupHelper-Version ${SETUP_HELPER_VERSION_RAW:-${SETUP_HELPER_VERSION_NORMALIZED}} erfüllt die Mindestanforderung ${required_version}"
}

require_python3() {
  if ! command -v python3 >/dev/null 2>&1; then
    die "python3 ist nicht installiert. Bitte installieren Sie python3, bevor Sie fortfahren."
  fi
}

require_python_module() {
  local module_name="$1"

  if [[ -z "${module_name}" ]]; then
    return
  fi

  set +e
  local output=""
  output="$(python3 - "${module_name}" <<'PY'
import importlib
import sys

module_name = sys.argv[1]

try:
    importlib.import_module(module_name)
except Exception as exc:  # pragma: no cover - best effort logging
    raise SystemExit(str(exc))
PY
)"
  local status=$?
  set -e

  if (( status != 0 )); then
    if [[ -n "${output}" ]]; then
      log ERROR "python3 -c 'import ${module_name}' fehlgeschlagen: ${output}"
    fi
    die "Das Python-Modul ${module_name} ist nicht verfügbar. Installieren Sie die Komponente und versuchen Sie es erneut."
  fi
}

copy_tree() {
  local src="$1"
  local dest="$2"
  mkdir -p "${dest}"
  if command -v rsync >/dev/null 2>&1; then
    rsync -a --delete "${src}/" "${dest}/"
  else
    if [[ -d "${dest}" ]]; then
      find "${dest}" -mindepth 1 -exec rm -rf {} +
    fi
    tar -C "${src}" -cf - . | tar -C "${dest}" -xf -
  fi
}
call_helper_function_if_available() {
  local fn="$1"
  shift || true
  if ! declare -F "${fn}" >/dev/null; then
    return 127
  fi

  # Temporär striktes Fehler-Handling deaktivieren, um alternative Aufrufe
  # ausprobieren zu können, ohne das Skript sofort abzubrechen.
  set +e
  "${fn}" "$@"
  local status=$?
  set -e
  return ${status}
}

define_builtin_helper_fallback() {
  if [[ -n "${__DPLUS_HELPER_FALLBACK_DEFINED:-}" ]]; then
    return
  fi

  __DPLUS_HELPER_FALLBACK_DEFINED=1
  log WARN "Keine externen SetupHelper-Ressourcen gefunden – verwende integrierten Fallback"

  __dplus_helper_project_root="${PROJECT_ROOT:-$(pwd)}"
  __dplus_helper_state_dir="${__dplus_helper_project_root}/SetupHelper/.helper_state"
  mkdir -p "${__dplus_helper_state_dir}"

  logMessage() {
    local level="${1:-INFO}"
    shift || true
    local timestamp
    timestamp="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
    printf '[HELPER][%s][%s] %s\n' "${timestamp}" "${level^^}" "$*"
  }

  helper_begin() {
    logMessage INFO "Starte Helper-Sitzung"
    mkdir -p "${__dplus_helper_state_dir}"
    return 0
  }

  helper_end() {
    local flags="$*"
    if [[ -n "${flags}" ]]; then
      logMessage INFO "Beende Helper-Sitzung (Flags: ${flags})"
    else
      logMessage INFO "Beende Helper-Sitzung"
    fi
    return 0
  }

  beginScript() {
    helper_begin
  }

  endScript() {
    helper_end "$@"
  }

  helper_enable_dependency_conflict_checks() {
    logMessage INFO "Aktiviere Konfliktprüfungen (Fallback-No-Op)"
    return 0
  }

  helper_enable_package_conflict_checks() {
    helper_enable_dependency_conflict_checks
  }

  __dplus_helper_store_dependencies() {
    local src_file="$1"
    local dest_file="${__dplus_helper_state_dir}/packageDependencies"
    if [[ ! -r "${src_file}" ]]; then
      logMessage ERROR "packageDependencies-Datei ${src_file} ist nicht lesbar"
      return 1
    fi
    cp "${src_file}" "${dest_file}"
    logMessage INFO "Registriere packageDependencies aus ${src_file}"
    return 0
  }

  helper_register_package_dependencies() {
    __dplus_helper_store_dependencies "$1"
  }

  helper_use_package_dependencies() {
    __dplus_helper_store_dependencies "$1"
  }

  checkPackageDependencies() {
    local src_file="${1:-${__dplus_helper_project_root}/packageDependencies}"
    if [[ -z "${src_file}" ]]; then
      src_file="${__dplus_helper_project_root}/packageDependencies"
    fi
    __dplus_helper_store_dependencies "${src_file}"
  }

  helper_runtime_notice() {
    logMessage INFO "$*"
  }

  __dplus_helper_service_state_dir="${__dplus_helper_state_dir}/services"
  mkdir -p "${__dplus_helper_service_state_dir}"

  __dplus_helper_service_link_dir="${INSTALL_ROOT:-${__dplus_helper_project_root}/.install}/service-links"
  mkdir -p "${__dplus_helper_service_link_dir}"

  __dplus_helper_mark_service_installed() {
    local service_name="$1"
    local service_dir="$2"
    ln -sfn "${service_dir}" "${__dplus_helper_service_state_dir}/${service_name}"
    ln -sfn "${service_dir}" "${__dplus_helper_service_link_dir}/${service_name}"
    logMessage INFO "Dienst ${service_name} wurde für die lokale Installation verknüpft"
  }

  helper_install_service() {
    local service_name="$1"
    local service_dir="$2"
    if [[ -z "${service_name}" || -z "${service_dir}" ]]; then
      logMessage ERROR "Ungültige Parameter für helper_install_service"
      return 1
    fi
    if [[ ! -d "${service_dir}" ]]; then
      logMessage ERROR "Dienstverzeichnis ${service_dir} existiert nicht"
      return 1
    fi
    __dplus_helper_mark_service_installed "${service_name}" "${service_dir}"
    return 0
  }

  installService() {
    helper_install_service "$@"
  }

  helper_uninstall_service() {
    local service_name="$1"
    rm -f "${__dplus_helper_service_state_dir}/${service_name}"
    rm -f "${__dplus_helper_service_link_dir}/${service_name}"
    logMessage INFO "Dienst ${service_name} wurde aus der lokalen Installation entfernt"
    return 0
  }

  removeService() {
    helper_uninstall_service "$@"
  }

  helper_print_service_status() {
    local service_name="$1"
    if [[ -L "${__dplus_helper_service_state_dir}/${service_name}" ]]; then
      printf 'Dienst %s ist lokal verknüpft.\n' "${service_name}"
    else
      printf 'Dienst %s ist nicht verknüpft.\n' "${service_name}"
    fi
  }

  serviceIsUp() {
    local service_name="$1"
    if [[ -L "${__dplus_helper_service_state_dir}/${service_name}" ]]; then
      return 0
    fi
    return 1
  }

  __dplus_helper_settings_state_dir="${__dplus_helper_state_dir}/dbus_settings"
  mkdir -p "${__dplus_helper_settings_state_dir}"

  DbusSettingsList() {
    printf '%s\n' "$@"
  }

  __dplus_helper_store_settings_lines() {
    local dest_file="$1"
    shift || true
    printf '%s\n' "$@" > "${dest_file}"
  }

  addAllDbusSettingsFromFile() {
    local settings_file="$1"
    if [[ ! -r "${settings_file}" ]]; then
      logMessage ERROR "D-Bus-Definition ${settings_file} ist nicht lesbar"
      return 1
    fi
    local dest_file="${__dplus_helper_settings_state_dir}/registered_from_file.list"
    cp "${settings_file}" "${dest_file}"
    logMessage INFO "Registriere D-Bus-Einstellungen aus ${settings_file}"
    return 0
  }

  addAllDbusSettings() {
    if [[ $# -eq 1 && -f "$1" ]]; then
      addAllDbusSettingsFromFile "$1"
      return $?
    fi
    local dest_file="${__dplus_helper_settings_state_dir}/registered_inline.list"
    __dplus_helper_store_settings_lines "${dest_file}" "$@"
    logMessage INFO "Registriere D-Bus-Einstellungen aus Argumentliste"
    return 0
  }

  removeDbusSettingsFromFile() {
    local settings_file="$1"
    if [[ -f "${__dplus_helper_settings_state_dir}/registered_from_file.list" ]]; then
      rm -f "${__dplus_helper_settings_state_dir}/registered_from_file.list"
      logMessage INFO "Deregistriere D-Bus-Einstellungen (Datei ${settings_file})"
    else
      logMessage INFO "Keine registrierten D-Bus-Einstellungen aus Datei vorhanden"
    fi
    return 0
  }

  removeDbusSettings() {
    if [[ $# -eq 1 && -f "$1" ]]; then
      removeDbusSettingsFromFile "$1"
      return 0
    fi
    rm -f "${__dplus_helper_settings_state_dir}/registered_inline.list"
    logMessage INFO "Deregistriere D-Bus-Einstellungen aus Argumentliste"
    return 0
  }

  helper_register_settings_with_metadata() {
    local dest_file="${__dplus_helper_settings_state_dir}/metadata.list"
    cat > "${dest_file}"
    logMessage INFO "Registriere Einstellungen inklusive Metadaten"
    return 0
  }

  helper_register_settings() {
    local dest_file="${__dplus_helper_settings_state_dir}/simple.list"
    cat > "${dest_file}"
    logMessage INFO "Registriere Einstellungen ohne Metadaten"
    return 0
  }

  helper_unregister_settings() {
    local base_path="$1"
    rm -f "${__dplus_helper_settings_state_dir}/"*.list 2>/dev/null || true
    logMessage INFO "Deregistriere Einstellungen unter Basis ${base_path}"
    return 0
  }
}

source_helper_resources() {
  local -a search_candidates=()
  local candidate=""

  SETUP_HELPER_DETECTED_ROOT=""

  if [[ -n "${SETUP_HELPER_ROOT:-}" ]]; then
    if [[ -d "${SETUP_HELPER_ROOT}" ]]; then
      search_candidates+=("${SETUP_HELPER_ROOT}/HelperResources")
    elif [[ -f "${SETUP_HELPER_ROOT}" ]]; then
      search_candidates+=("${SETUP_HELPER_ROOT}")
    fi
  fi

  if [[ -n "${HELPER_RESOURCE:-}" ]]; then
    search_candidates+=("${HELPER_RESOURCE}")
  fi

  search_candidates+=(
    "${PROJECT_ROOT}/SetupHelper/HelperResources"
    "/data/SetupHelper/HelperResources"
    "/opt/venus/SetupHelper/HelperResources"
    "/opt/venusOS/SetupHelper/HelperResources"
    "/usr/share/SetupHelper/HelperResources"
  )

  local helper_cmd=""
  for helper_cmd in setuphelper SetupHelper helperctl; do
    if command -v "${helper_cmd}" >/dev/null 2>&1; then
      local helper_bin
      helper_bin="$(command -v "${helper_cmd}")"
      local helper_root
      helper_root="$(cd "$(dirname "${helper_bin}")/.." && pwd -P 2>/dev/null)"
      if [[ -n "${helper_root}" ]]; then
        search_candidates+=("${helper_root}/HelperResources")
      fi
    fi
  done

  for candidate in "${search_candidates[@]}"; do
    [[ -z "${candidate}" ]] && continue

    if [[ -f "${candidate}" && -r "${candidate}" ]]; then
      remember_setup_helper_root "${candidate}"
      # shellcheck disable=SC1090
      source "${candidate}"
      return
    fi

    if [[ -d "${candidate}" ]]; then
      remember_setup_helper_root "${candidate}"
      if [[ -r "${candidate}/forSetupScript" ]]; then
        remember_setup_helper_root "${candidate}/forSetupScript"
        # shellcheck disable=SC1090
        source "${candidate}/forSetupScript"
        return
      fi

      if [[ -r "${candidate}/IncludeHelpers" ]]; then
        remember_setup_helper_root "${candidate}/IncludeHelpers"
        # shellcheck disable=SC1090
        source "${candidate}/IncludeHelpers"
        return
      fi

      local -a helper_files=(
        "${candidate}/CommonResources"
        "${candidate}/ServiceResources"
        "${candidate}/DbusSettingsResources"
      )

      local file=""
      local missing=0
      for file in "${helper_files[@]}"; do
        if [[ -r "${file}" ]]; then
          # shellcheck disable=SC1090
          source "${file}"
        else
          missing=1
          break
        fi
      done

      if (( missing == 0 )); then
        return
      fi
    fi
  done

  define_builtin_helper_fallback
}

begin_helper_session() {
  if declare -F beginScript >/dev/null; then
    beginScript
    return
  fi
  if declare -F helper_begin >/dev/null; then
    helper_begin
  fi
}

end_helper_session() {
  if declare -F endScript >/dev/null; then
    endScript "$@"
    return
  fi
  if declare -F helper_end >/dev/null; then
    helper_end "$@"
  fi
}

finalize_helper_session() {
  local -a helper_flags=()

  if [[ "${filesUpdated}" == true ]]; then
    helper_flags+=("INSTALL_FILES")
  fi
  if [[ "${servicesUpdated}" == true ]]; then
    helper_flags+=("INSTALL_SERVICES")
  fi
  if [[ "${dbusSettingsUpdated}" == true ]]; then
    helper_flags+=("ADD_DBUS_SETTINGS")
  fi

  local end_status=0
  if ! end_helper_session "${helper_flags[@]}"; then
    end_status=$?
  fi

  cleanup_dbus_settings_state "${end_status}"

  return ${end_status}
}

install_service() {
  if call_helper_function_if_available installService "${SERVICE_NAME}" "${SERVICE_INSTALL_DIR}"; then
    return
  fi
  if call_helper_function_if_available helper_install_service "${SERVICE_NAME}" "${SERVICE_INSTALL_DIR}"; then
    return
  fi
  die "SetupHelper stellt keine Funktion zum Installieren des Dienstes bereit"
}

remove_service() {
  if call_helper_function_if_available removeService "${SERVICE_NAME}"; then
    return
  fi
  if call_helper_function_if_available helper_uninstall_service "${SERVICE_NAME}"; then
    return
  fi
  die "SetupHelper stellt keine Funktion zum Entfernen des Dienstes bereit"
}

build_dbus_settings_entries() {
  local list_path="$1"
  if [[ ! -f "${list_path}" ]]; then
    die "settingsList ${list_path} nicht gefunden"
  fi
  mapfile -t _dbus_settings_entries < "${list_path}"

  local sanitized_entries=()
  local entry=""
  for entry in "${_dbus_settings_entries[@]}"; do
    local trimmed=""
    trimmed="$(trim_whitespace "${entry}")"
    if [[ -n "${trimmed}" ]]; then
      sanitized_entries+=("${trimmed}")
    fi
  done

  _dbus_settings_entries=("${sanitized_entries[@]}")

  if (( ${#_dbus_settings_entries[@]} > 0 )); then
    _dbus_settings_multiline="$(printf '%s\n' "${_dbus_settings_entries[@]}")"
  else
    _dbus_settings_multiline=""
  fi
}

write_dbus_settings_file() {
  local output_path="$1"

  if (( ${#_dbus_settings_entries[@]} > 0 )); then
    printf '%s\n' "${_dbus_settings_entries[@]}" > "${output_path}"
  else
    : > "${output_path}"
  fi
}

reset_dbus_settings_tracking() {
  DBUS_SETTINGS_PERSISTENT_FILE="${INSTALL_ROOT}/${DBUS_SETTINGS_FILENAME}"
  DBUS_SETTINGS_STAGING_BACKUP=""
  DBUS_SETTINGS_PERSISTENT_BACKUP=""
  DBUS_SETTINGS_STAGING_CREATED=false
  DBUS_SETTINGS_PERSISTENT_UPDATED=false
  DBUS_SETTINGS_OPERATION=""
}

cleanup_dbus_settings_state() {
  local end_status="${1:-0}"
  local staging_file="${DBUS_SETTINGS_STAGING_FILE}"
  local persistent_file="${DBUS_SETTINGS_PERSISTENT_FILE:-${INSTALL_ROOT}/${DBUS_SETTINGS_FILENAME}}"

  if (( end_status != 0 )); then
    if [[ -n "${DBUS_SETTINGS_STAGING_BACKUP}" && -f "${DBUS_SETTINGS_STAGING_BACKUP}" ]]; then
      mv -f "${DBUS_SETTINGS_STAGING_BACKUP}" "${staging_file}"
    elif [[ "${DBUS_SETTINGS_STAGING_CREATED}" == true ]]; then
      rm -f "${staging_file}"
    fi

    if [[ -n "${DBUS_SETTINGS_PERSISTENT_BACKUP}" && -f "${DBUS_SETTINGS_PERSISTENT_BACKUP}" ]]; then
      mv -f "${DBUS_SETTINGS_PERSISTENT_BACKUP}" "${persistent_file}"
    elif [[ "${DBUS_SETTINGS_PERSISTENT_UPDATED}" == true ]]; then
      rm -f "${persistent_file}"
    fi
  else
    if [[ -n "${DBUS_SETTINGS_STAGING_BACKUP}" && -f "${DBUS_SETTINGS_STAGING_BACKUP}" ]]; then
      rm -f "${DBUS_SETTINGS_STAGING_BACKUP}"
    fi

    if [[ -n "${DBUS_SETTINGS_PERSISTENT_BACKUP}" && -f "${DBUS_SETTINGS_PERSISTENT_BACKUP}" ]]; then
      rm -f "${DBUS_SETTINGS_PERSISTENT_BACKUP}"
    fi

    if [[ "${DBUS_SETTINGS_STAGING_CREATED}" == true ]]; then
      rm -f "${staging_file}"
    fi
  fi

  reset_dbus_settings_tracking
}

register_dbus_settings() {
  local list_path="${PROJECT_ROOT}/settingsList"
  local staging_file="${DBUS_SETTINGS_STAGING_FILE}"
  local persistent_file="${INSTALL_ROOT}/${DBUS_SETTINGS_FILENAME}"
  local registration_success=false

  DBUS_SETTINGS_OPERATION="register"
  DBUS_SETTINGS_PERSISTENT_FILE="${persistent_file}"
  DBUS_SETTINGS_STAGING_BACKUP=""
  DBUS_SETTINGS_PERSISTENT_BACKUP=""
  DBUS_SETTINGS_STAGING_CREATED=false
  DBUS_SETTINGS_PERSISTENT_UPDATED=false

  build_dbus_settings_entries "${list_path}"

  if (( ${#_dbus_settings_entries[@]} == 0 )); then
    die "Es konnten keine D-Bus-Definitionen für die Registrierung generiert werden"
  fi

  if [[ -f "${staging_file}" ]]; then
    DBUS_SETTINGS_STAGING_BACKUP="$(mktemp "${TMPDIR:-/tmp}/DbusSettingsList.backup.XXXXXX")"
    cp -f "${staging_file}" "${DBUS_SETTINGS_STAGING_BACKUP}"
  fi

  write_dbus_settings_file "${staging_file}"
  DBUS_SETTINGS_STAGING_CREATED=true

  mkdir -p "${INSTALL_ROOT}"
  if [[ -f "${persistent_file}" ]]; then
    DBUS_SETTINGS_PERSISTENT_BACKUP="$(mktemp "${TMPDIR:-/tmp}/DbusSettingsList.persist.backup.XXXXXX")"
    cp -f "${persistent_file}" "${DBUS_SETTINGS_PERSISTENT_BACKUP}"
  fi
  install -m 644 "${staging_file}" "${persistent_file}"
  DBUS_SETTINGS_PERSISTENT_UPDATED=true

  if declare -F endScript >/dev/null && [[ -z "${__DPLUS_HELPER_FALLBACK_DEFINED:-}" ]]; then
    dbusSettingsUpdated=true
    return
  fi

  if call_helper_function_if_available addAllDbusSettings; then
    registration_success=true
  elif call_helper_function_if_available addAllDbusSettings "${staging_file}"; then
    registration_success=true
  elif [[ -n "${_dbus_settings_multiline}" ]] && call_helper_function_if_available addAllDbusSettings "${_dbus_settings_multiline}"; then
    registration_success=true
  fi

  if [[ "${registration_success}" == true ]]; then
    dbusSettingsUpdated=true
    return
  fi

  if [[ -n "${DBUS_SETTINGS_STAGING_BACKUP}" ]]; then
    mv -f "${DBUS_SETTINGS_STAGING_BACKUP}" "${staging_file}"
    DBUS_SETTINGS_STAGING_BACKUP=""
  elif [[ "${DBUS_SETTINGS_STAGING_CREATED}" == true ]]; then
    rm -f "${staging_file}"
  fi

  if [[ -n "${DBUS_SETTINGS_PERSISTENT_BACKUP}" ]]; then
    mv -f "${DBUS_SETTINGS_PERSISTENT_BACKUP}" "${persistent_file}"
    DBUS_SETTINGS_PERSISTENT_BACKUP=""
  elif [[ "${DBUS_SETTINGS_PERSISTENT_UPDATED}" == true ]]; then
    rm -f "${persistent_file}"
  fi

  die "SetupHelper stellt keine geeignete Funktion zum Registrieren der Einstellungen bereit"
}

unregister_dbus_settings() {
  local list_path="${PROJECT_ROOT}/settingsList"
  local staging_file="${DBUS_SETTINGS_STAGING_FILE}"
  local persistent_file="${INSTALL_ROOT}/${DBUS_SETTINGS_FILENAME}"
  local removal_success=false
  local removal_payload=""

  DBUS_SETTINGS_OPERATION="unregister"
  DBUS_SETTINGS_PERSISTENT_FILE="${persistent_file}"
  DBUS_SETTINGS_STAGING_BACKUP=""
  DBUS_SETTINGS_PERSISTENT_BACKUP=""
  DBUS_SETTINGS_STAGING_CREATED=false
  DBUS_SETTINGS_PERSISTENT_UPDATED=false

  build_dbus_settings_entries "${list_path}"

  if [[ -f "${staging_file}" ]]; then
    DBUS_SETTINGS_STAGING_BACKUP="$(mktemp "${TMPDIR:-/tmp}/DbusSettingsList.backup.XXXXXX")"
    cp -f "${staging_file}" "${DBUS_SETTINGS_STAGING_BACKUP}"
  fi

  if (( ${#_dbus_settings_entries[@]} > 0 )); then
    write_dbus_settings_file "${staging_file}"
    DBUS_SETTINGS_STAGING_CREATED=true
  fi

  if [[ -f "${staging_file}" ]]; then
    removal_payload="${staging_file}"
  elif [[ -f "${persistent_file}" ]]; then
    removal_payload="${persistent_file}"
  fi

  if call_helper_function_if_available removeAllDbusSettings; then
    removal_success=true
  elif [[ -n "${removal_payload}" ]] && call_helper_function_if_available removeAllDbusSettings "${removal_payload}"; then
    removal_success=true
  elif [[ -n "${_dbus_settings_multiline}" ]] && call_helper_function_if_available removeAllDbusSettings "${_dbus_settings_multiline}"; then
    removal_success=true
  elif call_helper_function_if_available removeDbusSettings; then
    removal_success=true
  elif [[ -n "${removal_payload}" ]] && call_helper_function_if_available removeDbusSettings "${removal_payload}"; then
    removal_success=true
  elif [[ -n "${_dbus_settings_multiline}" ]] && call_helper_function_if_available removeDbusSettings "${_dbus_settings_multiline}"; then
    removal_success=true
  elif [[ -z "${removal_payload}" && -z "${_dbus_settings_multiline}" ]]; then
    removal_success=true
  fi

  if [[ "${removal_success}" == true ]]; then
    if [[ -n "${removal_payload}" || -n "${_dbus_settings_multiline}" ]]; then
      dbusSettingsUpdated=true
    fi
    return
  fi

  if [[ -n "${DBUS_SETTINGS_STAGING_BACKUP}" ]]; then
    mv -f "${DBUS_SETTINGS_STAGING_BACKUP}" "${staging_file}"
    DBUS_SETTINGS_STAGING_BACKUP=""
  elif [[ "${DBUS_SETTINGS_STAGING_CREATED}" == true ]]; then
    rm -f "${staging_file}"
  fi

  die "Deregistrierung der D-Bus-Settings fehlgeschlagen"
}

service_is_up() {
  if declare -F serviceIsUp >/dev/null; then
    set +e
    serviceIsUp "${SERVICE_NAME}"
    local status=$?
    set -e
    return ${status}
  fi

  if declare -F helper_print_service_status >/dev/null; then
    helper_print_service_status "${SERVICE_NAME}"
    return 0
  fi

  log INFO "Statusabfrage für Dienst ${SERVICE_NAME} nicht verfügbar"
  return 1
}

register_package_dependencies() {
  local resolved_action="${scriptAction:-}"

  LAST_PACKAGE_DEPENDENCY_CHECK_STATUS=""
  LAST_PACKAGE_DEPENDENCY_CHECK_ACTION=""
  LAST_PACKAGE_DEPENDENCY_CHECK_INSTALL_FAILED=""
  LAST_PACKAGE_DEPENDENCY_CHECK_FAIL_MESSAGE=""
  LAST_PACKAGE_DEPENDENCY_CHECK_CONFLICT=false

  if [[ -z "${resolved_action}" ]]; then
    case "${RESOLVED_CLI_ACTION:-}" in
      install|INSTALL)
        resolved_action="INSTALL"
        ;;
      uninstall|UNINSTALL)
        resolved_action="UNINSTALL"
        ;;
      status|check|STATUS)
        resolved_action="CHECK"
        ;;
    esac
  fi

  local normalized_action=""
  if [[ -n "${resolved_action}" ]]; then
    normalized_action="${resolved_action^^}"
  fi

  if [[ "${normalized_action}" != "INSTALL" ]]; then
    if [[ -n "${normalized_action}" ]]; then
      log INFO "Überspringe packageDependencies-Prüfung (Aktion ${normalized_action})"
    else
      log INFO "Überspringe packageDependencies-Prüfung (keine Installationsaktion erkannt)"
    fi
    return
  fi

  if [[ ! -f "${PACKAGE_DEPENDENCIES_FILE}" ]]; then
    log WARN "packageDependencies-Datei fehlt, überspringe Registrierung"
    return
  fi

  local status=0
  if call_helper_function_if_available checkPackageDependencies "${PACKAGE_DEPENDENCIES_FILE}"; then
    status=$?
  else
    status=$?
  fi

  local helper_action_after="${scriptAction:-}"
  local helper_install_failed="${installFailed:-}"
  local helper_install_fail_message="${installFailMessage:-}"
  local normalized_action_after=""
  if [[ -n "${helper_action_after}" ]]; then
    normalized_action_after="${helper_action_after^^}"
  fi

  local normalized_install_failed="${helper_install_failed,,}"
  local helper_conflict_detected=false
  case "${normalized_install_failed}" in
    true|1|yes)
      helper_conflict_detected=true
      ;;
  esac

  if [[ -n "${normalized_action_after}" && "${normalized_action_after}" != "INSTALL" ]]; then
    helper_conflict_detected=true
  fi

  LAST_PACKAGE_DEPENDENCY_CHECK_STATUS="${status}"
  LAST_PACKAGE_DEPENDENCY_CHECK_ACTION="${helper_action_after}"
  LAST_PACKAGE_DEPENDENCY_CHECK_INSTALL_FAILED="${helper_install_failed}"
  LAST_PACKAGE_DEPENDENCY_CHECK_FAIL_MESSAGE="${helper_install_fail_message}"
  LAST_PACKAGE_DEPENDENCY_CHECK_CONFLICT="${helper_conflict_detected}"

  if (( status == 0 )); then
    if [[ "${helper_conflict_detected}" == true ]]; then
      local conflict_message="${helper_install_fail_message}"
      if [[ -z "${conflict_message}" ]]; then
        if [[ -n "${normalized_action_after}" && "${normalized_action_after}" != "INSTALL" ]]; then
          conflict_message="SetupHelper hat die Aktion ${normalized_action_after} angefordert; Installation wird abgebrochen."
        else
          conflict_message="SetupHelper meldete Paketkonflikte; die Installation wird abgebrochen."
        fi
      else
        if [[ -n "${normalized_action_after}" && "${normalized_action_after}" != "INSTALL" ]]; then
          conflict_message="${conflict_message} (scriptAction=${normalized_action_after})"
        fi
      fi
      die "${conflict_message}"
    fi

    return
  fi

  if (( status == 127 )); then
    log INFO "SetupHelper stellt keine Funktion checkPackageDependencies bereit; überspringe packageDependencies-Prüfung"
    return
  fi

  die "checkPackageDependencies meldete Fehler (Status ${status}); Installation abgebrochen"
}


install_payload() {
  log INFO "Installationsdateien nach ${INSTALL_ROOT} kopieren"
  mkdir -p "${INSTALL_ROOT}"

  copy_tree "${PROJECT_ROOT}/src" "${INSTALL_ROOT}/src"
  copy_tree "${PROJECT_ROOT}/services" "${INSTALL_ROOT}/services"

  install -m 644 "${PROJECT_ROOT}/src/settings_schema.json" "${INSTALL_ROOT}/settings_schema.json"
  install -m 644 "${PROJECT_ROOT}/version" "${INSTALL_ROOT}/version"
  install -m 644 "${PROJECT_ROOT}/packageDependencies" "${INSTALL_ROOT}/packageDependencies"
  install -m 644 "${PROJECT_ROOT}/gitHubInfo" "${INSTALL_ROOT}/gitHubInfo"
  install -m 644 "${PROJECT_ROOT}/settingsList" "${INSTALL_ROOT}/settingsList"

  if [[ -d "${PROJECT_ROOT}/FileSets" ]]; then
    copy_tree "${PROJECT_ROOT}/FileSets" "${INSTALL_ROOT}/FileSets"
  fi
}

perform_install_preflight() {
  log INFO "Starte Preflight-Prüfung der Installationsumgebung"
  require_setuphelper_version "${REQUIRED_SETUP_HELPER_VERSION}"
  require_python3
  log INFO "python3 wurde gefunden"
  require_python_module "dbus_next"
  log INFO "Python-Modul dbus_next ist verfügbar"
}

perform_install() {
  filesUpdated=false
  servicesUpdated=false
  dbusSettingsUpdated=false

  perform_install_preflight

  begin_helper_session
  register_package_dependencies

  install_payload
  filesUpdated=true

  install_service
  servicesUpdated=true

  register_dbus_settings

  finalize_helper_session
  log INFO "Installation abgeschlossen"
}

perform_uninstall() {
  filesUpdated=false
  servicesUpdated=false
  dbusSettingsUpdated=false

  begin_helper_session
  register_package_dependencies

  unregister_dbus_settings

  remove_service
  servicesUpdated=true

  if [[ -d "${INSTALL_ROOT}" ]]; then
    log INFO "Entferne Installationsverzeichnis ${INSTALL_ROOT}"
    rm -rf "${INSTALL_ROOT}"
    filesUpdated=true
  fi

  finalize_helper_session
  log INFO "Deinstallation abgeschlossen"
}

perform_status() {
  filesUpdated=false
  servicesUpdated=false
  dbusSettingsUpdated=false

  begin_helper_session
  register_package_dependencies

  local status_reported=false
  if declare -F serviceIsUp >/dev/null; then
    if service_is_up; then
      log INFO "Dienst ${SERVICE_NAME} ist aktiv"
    else
      log WARN "Dienst ${SERVICE_NAME} ist nicht aktiv"
    fi
    status_reported=true
  fi

  if [[ "${status_reported}" == false ]] && declare -F helper_print_service_status >/dev/null; then
    helper_print_service_status "${SERVICE_NAME}"
    status_reported=true
  fi

  if [[ "${status_reported}" == false ]]; then
    log WARN "Keine Statusfunktion für Dienst ${SERVICE_NAME} verfügbar"
  fi

  finalize_helper_session
}

usage() {
  cat <<USAGE
Verwendung: ${0##*/} <install|uninstall|status>
USAGE
}

main() {
  local cli_action="${1:-}"
  local normalized_cli=""

  if [[ -n "${cli_action}" ]]; then
    case "${cli_action}" in
      install|uninstall|status)
        normalized_cli="${cli_action}"
        ;;
      -h|--help)
        usage
        return 0
        ;;
      *)
        usage
        return 1
        ;;
    esac
  fi

  local helper_action="${scriptAction:-}"
  if [[ -z "${helper_action}" ]]; then
    case "${normalized_cli:-install}" in
      install)
        helper_action="INSTALL"
        normalized_cli="install"
        ;;
      uninstall)
        helper_action="UNINSTALL"
        ;;
      status)
        helper_action="CHECK"
        ;;
    esac
  else
    local expected_from_cli=""
    case "${normalized_cli}" in
      install) expected_from_cli="INSTALL" ;;
      uninstall) expected_from_cli="UNINSTALL" ;;
      status) expected_from_cli="CHECK" ;;
    esac

    if [[ -n "${expected_from_cli}" && "${helper_action}" != "${expected_from_cli}" ]]; then
      log WARN "scriptAction ${helper_action} stimmt nicht mit der CLI-Aktion ${normalized_cli} überein; verwende CLI-Aktion"
      helper_action="${expected_from_cli}"
    fi

    if [[ -z "${normalized_cli}" ]]; then
      case "${helper_action}" in
        INSTALL) normalized_cli="install" ;;
        UNINSTALL) normalized_cli="uninstall" ;;
        CHECK) normalized_cli="status" ;;
        *)
          log WARN "Unbekannte scriptAction ${helper_action}, verwende INSTALL"
          helper_action="INSTALL"
          normalized_cli="install"
          ;;
      esac
    fi
  fi

  scriptAction="${helper_action}"

  if [[ -n "${normalized_cli}" ]]; then
    RESOLVED_CLI_ACTION="${normalized_cli}"
  else
    case "${scriptAction}" in
      INSTALL)
        RESOLVED_CLI_ACTION="install"
        ;;
      UNINSTALL)
        RESOLVED_CLI_ACTION="uninstall"
        ;;
      CHECK)
        RESOLVED_CLI_ACTION="status"
        ;;
      *)
        RESOLVED_CLI_ACTION=""
        ;;
    esac
  fi

  source_helper_resources

  case "${scriptAction}" in
    INSTALL)
      perform_install
      ;;
    UNINSTALL)
      perform_uninstall
      ;;
    CHECK)
      perform_status
      ;;
    *)
      log ERROR "Unbekannte scriptAction ${scriptAction}"
      usage
      return 1
      ;;
  esac
}

if [[ -z "${DPLUS_SIMULATOR_SKIP_MAIN:-}" ]]; then
  main "$@"
fi
