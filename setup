#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="${SCRIPT_DIR}"
INSTALL_ROOT="${INSTALL_ROOT:-/opt/dplus_sim}"
SERVICE_NAME="com.coyodude.dplussim"
SERVICE_INSTALL_DIR="${INSTALL_ROOT}/services/${SERVICE_NAME}"
HELPER_RESOURCE="/data/SetupHelper/HelperResources/forSetupScript"
SETTINGS_BASE_PATH="/Settings/Devices/DPlusSim"
PACKAGE_DEPENDENCIES_FILE="${PROJECT_ROOT}/packageDependencies"

log() {
  local level="$1"
  shift
  printf '[%s] %s\n' "${level}" "$*"
}

die() {
  log ERROR "$*"
  exit 1
}

copy_tree() {
  local src="$1"
  local dest="$2"
  mkdir -p "${dest}"
  if command -v rsync >/dev/null 2>&1; then
    rsync -a --delete "${src}/" "${dest}/"
  else
    tar -C "${src}" -cf - . | tar -C "${dest}" -xf -
  fi
}

require_helper_function() {
  local fn="$1"
  if ! declare -F "${fn}" >/dev/null; then
    die "SetupHelper stellt die benötigte Funktion ${fn} nicht bereit"
  fi
}

source_setup_helper() {
  if [[ ! -r "${HELPER_RESOURCE}" ]]; then
    die "SetupHelper-Ressource ${HELPER_RESOURCE} nicht gefunden"
  fi
  # shellcheck disable=SC1090
  source "${HELPER_RESOURCE}"

  local required_functions=(
    helper_begin
    helper_end
    helper_install_service
    helper_uninstall_service
    helper_print_service_status
    helper_register_settings
    helper_unregister_settings
  )
  for fn in "${required_functions[@]}"; do
    require_helper_function "${fn}"
  done
}

register_package_dependencies() {
  if [[ ! -f "${PACKAGE_DEPENDENCIES_FILE}" ]]; then
    log WARN "packageDependencies-Datei fehlt, überspringe Registrierung"
    return
  fi

  if declare -F helper_enable_dependency_conflict_checks >/dev/null; then
    helper_enable_dependency_conflict_checks
  elif declare -F helper_enable_package_conflict_checks >/dev/null; then
    helper_enable_package_conflict_checks
  else
    log WARN "SetupHelper bietet keine Konfliktprüfung, Registrierung läuft ohne zusätzliche Prüfung"
  fi

  if declare -F helper_register_package_dependencies >/dev/null; then
    helper_register_package_dependencies "${PACKAGE_DEPENDENCIES_FILE}"
  elif declare -F helper_use_package_dependencies >/dev/null; then
    helper_use_package_dependencies "${PACKAGE_DEPENDENCIES_FILE}"
  else
    die "SetupHelper unterstützt das Registrieren von packageDependencies nicht"
  fi
}

install_payload() {
  log INFO "Installationsdateien nach ${INSTALL_ROOT} kopieren"
  mkdir -p "${INSTALL_ROOT}"

  copy_tree "${PROJECT_ROOT}/src" "${INSTALL_ROOT}/src"
  copy_tree "${PROJECT_ROOT}/services" "${INSTALL_ROOT}/services"

  install -m 644 "${PROJECT_ROOT}/src/settings_schema.json" "${INSTALL_ROOT}/settings_schema.json"
  install -m 644 "${PROJECT_ROOT}/version" "${INSTALL_ROOT}/version"
  install -m 644 "${PROJECT_ROOT}/packageDependencies" "${INSTALL_ROOT}/packageDependencies"
  install -m 644 "${PROJECT_ROOT}/gitHubInfo" "${INSTALL_ROOT}/gitHubInfo"
  install -m 644 "${PROJECT_ROOT}/settingsList" "${INSTALL_ROOT}/settingsList"

  if [[ -d "${PROJECT_ROOT}/FileSets" ]]; then
    copy_tree "${PROJECT_ROOT}/FileSets" "${INSTALL_ROOT}/FileSets"
  fi
}

perform_install() {
  helper_begin
  register_package_dependencies

  install_payload

  helper_install_service "${SERVICE_NAME}" "${SERVICE_INSTALL_DIR}"
  if ! helper_register_settings "${PROJECT_ROOT}/settingsList" "${SETTINGS_BASE_PATH}"; then
    die "helper_register_settings konnte Einstellungen nicht registrieren"
  fi

  helper_end
  log INFO "Installation abgeschlossen"
}

perform_uninstall() {
  helper_begin
  register_package_dependencies

  if ! helper_unregister_settings "${SETTINGS_BASE_PATH}"; then
    log WARN "helper_unregister_settings konnte Einstellungen nicht deregistrieren"
  fi
  helper_uninstall_service "${SERVICE_NAME}"

  if [[ -d "${INSTALL_ROOT}" ]]; then
    log INFO "Entferne Installationsverzeichnis ${INSTALL_ROOT}"
    rm -rf "${INSTALL_ROOT}"
  fi

  helper_end
  log INFO "Deinstallation abgeschlossen"
}

perform_status() {
  helper_begin
  register_package_dependencies
  helper_print_service_status "${SERVICE_NAME}"
  helper_end
}

usage() {
  cat <<USAGE
Verwendung: ${0##*/} <install|uninstall|status>
USAGE
}

main() {
  local action="${1:-install}"

  source_setup_helper

  case "${action}" in
    install)
      perform_install
      ;;
    uninstall)
      perform_uninstall
      ;;
    status)
      perform_status
      ;;
    *)
      usage
      exit 1
      ;;
  esac
}

main "$@"
